From 904cf475635d450be360cb181e0e4fb6d0a19670 Mon Sep 17 00:00:00 2001
From: Cat73 <1901803382@qq.com>
Date: Fri, 19 Mar 2016 14:12:20 +0800
Subject: [PATCH] Cat73 -> mc-dev imports

这里的所有代码均应该直接从 MC 反编译结果里复制，并且不应做任何修改，任何 patch 都应该在其他文件里实现。
增加文件前请先检查 0003-mc-dev-imports.patch 里有无该文件，如果有则不应再在这里添加。
MC 版本没有更变的情况下，这里的东西都不需要变，但是 MC 版本更变如 1.9 -> 1.9.1，那就需要检查下这里的文件是否有变化。
Link：https://github.com/PaperMC/Paper/blob/master/Spigot-Server-Patches/0003-mc-dev-imports.patch

diff --git a/src/main/java/net/minecraft/server/BaseBlockPosition.java b/src/main/java/net/minecraft/server/BaseBlockPosition.java
new file mode 100644
index 0000000..e54e7b7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BaseBlockPosition.java
@@ -0,0 +1,93 @@
+package net.minecraft.server;
+
+import com.google.common.base.Objects;
+
+public class BaseBlockPosition implements Comparable<BaseBlockPosition> {
+
+    public static final BaseBlockPosition ZERO = new BaseBlockPosition(0, 0, 0);
+    private final int a;
+    private final int c;
+    private final int d;
+
+    public BaseBlockPosition(int i, int j, int k) {
+        this.a = i;
+        this.c = j;
+        this.d = k;
+    }
+
+    public BaseBlockPosition(double d0, double d1, double d2) {
+        this(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof BaseBlockPosition)) {
+            return false;
+        } else {
+            BaseBlockPosition baseblockposition = (BaseBlockPosition) object;
+
+            return this.getX() != baseblockposition.getX() ? false : (this.getY() != baseblockposition.getY() ? false : this.getZ() == baseblockposition.getZ());
+        }
+    }
+
+    public int hashCode() {
+        return (this.getY() + this.getZ() * 31) * 31 + this.getX();
+    }
+
+    public int i(BaseBlockPosition baseblockposition) {
+        return this.getY() == baseblockposition.getY() ? (this.getZ() == baseblockposition.getZ() ? this.getX() - baseblockposition.getX() : this.getZ() - baseblockposition.getZ()) : this.getY() - baseblockposition.getY();
+    }
+
+    public int getX() {
+        return this.a;
+    }
+
+    public int getY() {
+        return this.c;
+    }
+
+    public int getZ() {
+        return this.d;
+    }
+
+    public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+        return new BaseBlockPosition(this.getY() * baseblockposition.getZ() - this.getZ() * baseblockposition.getY(), this.getZ() * baseblockposition.getX() - this.getX() * baseblockposition.getZ(), this.getX() * baseblockposition.getY() - this.getY() * baseblockposition.getX());
+    }
+
+    public double f(int i, int j, int k) {
+        double d0 = (double) (this.getX() - i);
+        double d1 = (double) (this.getY() - j);
+        double d2 = (double) (this.getZ() - k);
+
+        return Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+    }
+
+    public double distanceSquared(double d0, double d1, double d2) {
+        double d3 = (double) this.getX() - d0;
+        double d4 = (double) this.getY() - d1;
+        double d5 = (double) this.getZ() - d2;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
+    }
+
+    public double f(double d0, double d1, double d2) {
+        double d3 = (double) this.getX() + 0.5D - d0;
+        double d4 = (double) this.getY() + 0.5D - d1;
+        double d5 = (double) this.getZ() + 0.5D - d2;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
+    }
+
+    public double k(BaseBlockPosition baseblockposition) {
+        return this.distanceSquared((double) baseblockposition.getX(), (double) baseblockposition.getY(), (double) baseblockposition.getZ());
+    }
+
+    public String toString() {
+        return Objects.toStringHelper(this).add("x", this.getX()).add("y", this.getY()).add("z", this.getZ()).toString();
+    }
+
+    public int compareTo(BaseBlockPosition object) {
+        return this.i(object);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockStateList.java b/src/main/java/net/minecraft/server/BlockStateList.java
new file mode 100644
index 0000000..a11c62f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockStateList.java
@@ -0,0 +1,325 @@
+package net.minecraft.server;
+
+import com.google.common.base.Function;
+import com.google.common.base.Objects;
+import com.google.common.collect.HashBasedTable;
+import com.google.common.collect.ImmutableCollection;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSortedMap;
+import com.google.common.collect.ImmutableTable;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.regex.Pattern;
+
+public class BlockStateList {
+
+    private static final Pattern a = Pattern.compile("^[a-z0-9_]+$");
+    private static final Function<IBlockState<?>, String> b = new Function() {
+        public String a(IBlockState<?> iblockstate) {
+            return iblockstate == null ? "<NULL>" : iblockstate.a();
+        }
+
+        public Object apply(Object object) {
+            return this.a((IBlockState) object);
+        }
+    };
+    private final Block c;
+    private final ImmutableSortedMap<String, IBlockState<?>> d;
+    private final ImmutableList<IBlockData> e;
+
+    public BlockStateList(Block block, IBlockState<?>... aiblockstate) {
+        this.c = block;
+        HashMap hashmap = Maps.newHashMap();
+        IBlockState[] aiblockstate1 = aiblockstate;
+        int i = aiblockstate.length;
+
+        for (int j = 0; j < i; ++j) {
+            IBlockState iblockstate = aiblockstate1[j];
+
+            a(block, iblockstate);
+            hashmap.put(iblockstate.a(), iblockstate);
+        }
+
+        this.d = ImmutableSortedMap.copyOf(hashmap);
+        LinkedHashMap linkedhashmap = Maps.newLinkedHashMap();
+        ArrayList arraylist = Lists.newArrayList();
+        Iterable iterable = IteratorUtils.a(this.e());
+        Iterator iterator = iterable.iterator();
+
+        while (iterator.hasNext()) {
+            List list = (List) iterator.next();
+            Map map = MapGeneratorUtils.b(this.d.values(), list);
+            BlockStateList.BlockData blockstatelist_blockdata = new BlockStateList.BlockData(block, ImmutableMap.copyOf(map), null);
+
+            linkedhashmap.put(map, blockstatelist_blockdata);
+            arraylist.add(blockstatelist_blockdata);
+        }
+
+        iterator = arraylist.iterator();
+
+        while (iterator.hasNext()) {
+            BlockStateList.BlockData blockstatelist_blockdata1 = (BlockStateList.BlockData) iterator.next();
+
+            blockstatelist_blockdata1.a((Map) linkedhashmap);
+        }
+
+        this.e = ImmutableList.copyOf(arraylist);
+    }
+
+    public static <T extends Comparable<T>> String a(Block block, IBlockState<T> iblockstate) {
+        String s = iblockstate.a();
+
+        if (!BlockStateList.a.matcher(s).matches()) {
+            throw new IllegalArgumentException("Block: " + block.getClass() + " has invalidly named property: " + s);
+        } else {
+            for (T t : iblockstate.c()) {
+                String s1 = iblockstate.a(t);
+
+                if (!a.matcher(s1).matches())
+                {
+                    throw new IllegalArgumentException("Block: " + block.getClass() + " has property: " + s + " with invalidly named value: " + s1);
+                }
+            }
+        }
+        return s;
+    }
+
+    public ImmutableList<IBlockData> a() {
+        return this.e;
+    }
+
+    private List<Iterable<Comparable<?>>> e() {
+        ArrayList arraylist = Lists.newArrayList();
+        ImmutableCollection immutablecollection = this.d.values();
+        Iterator iterator = immutablecollection.iterator();
+
+        while (iterator.hasNext()) {
+            IBlockState iblockstate = (IBlockState) iterator.next();
+
+            arraylist.add(iblockstate.c());
+        }
+
+        return arraylist;
+    }
+
+    public IBlockData getBlockData() {
+        return (IBlockData) this.e.get(0);
+    }
+
+    public Block getBlock() {
+        return this.c;
+    }
+
+    public Collection<IBlockState<?>> d() {
+        return this.d.values();
+    }
+
+    public String toString() {
+        return Objects.toStringHelper(this).add("block", Block.REGISTRY.b(this.c)).add("properties", Iterables.transform(this.d.values(), BlockStateList.b)).toString();
+    }
+
+    static class BlockData extends BlockDataAbstract {
+
+        private final Block a;
+        private final ImmutableMap<IBlockState<?>, Comparable<?>> b;
+        private ImmutableTable<IBlockState<?>, Comparable<?>, IBlockData> c;
+
+        private BlockData(Block block, ImmutableMap<IBlockState<?>, Comparable<?>> immutablemap) {
+            this.a = block;
+            this.b = immutablemap;
+        }
+
+        public Collection<IBlockState<?>> r() {
+            return Collections.unmodifiableCollection(this.b.keySet());
+        }
+
+        public <T extends Comparable<T>> T get(IBlockState<T> iblockstate) {
+            if (!this.b.containsKey(iblockstate)) {
+                throw new IllegalArgumentException("Cannot get property " + iblockstate + " as it does not exist in " + this.a.t());
+            } else {
+                return iblockstate.b().cast(this.b.get(iblockstate));
+            }
+        }
+
+        public <T extends Comparable<T>, V extends T> IBlockData set(IBlockState<T> iblockstate, V v0) {
+            if (!this.b.containsKey(iblockstate)) {
+                throw new IllegalArgumentException("Cannot set property " + iblockstate + " as it does not exist in " + this.a.t());
+            } else if (!iblockstate.c().contains(v0)) {
+                throw new IllegalArgumentException("Cannot set property " + iblockstate + " to " + v0 + " on block " + Block.REGISTRY.b(this.a) + ", it is not an allowed value");
+            } else {
+                return (IBlockData) (this.b.get(iblockstate) == v0 ? this : (IBlockData) this.c.get(iblockstate, v0));
+            }
+        }
+
+        public ImmutableMap<IBlockState<?>, Comparable<?>> s() {
+            return this.b;
+        }
+
+        public Block getBlock() {
+            return this.a;
+        }
+
+        public boolean equals(Object object) {
+            return this == object;
+        }
+
+        public int hashCode() {
+            return this.b.hashCode();
+        }
+
+        public void a(Map<Map<IBlockState<?>, Comparable<?>>, BlockStateList.BlockData> map) {
+            if (this.c != null) {
+                throw new IllegalStateException();
+            } else {
+                HashBasedTable hashbasedtable = HashBasedTable.create();
+                Iterator iterator = this.b.entrySet().iterator();
+
+                while (iterator.hasNext()) {
+                    Entry entry = (Entry) iterator.next();
+                    IBlockState iblockstate = (IBlockState) entry.getKey();
+                    Iterator iterator1 = iblockstate.c().iterator();
+
+                    while (iterator1.hasNext()) {
+                        Comparable comparable = (Comparable) iterator1.next();
+
+                        if (comparable != entry.getValue()) {
+                            hashbasedtable.put(iblockstate, comparable, map.get(this.b(iblockstate, comparable)));
+                        }
+                    }
+                }
+
+                this.c = ImmutableTable.copyOf(hashbasedtable);
+            }
+        }
+
+        private Map<IBlockState<?>, Comparable<?>> b(IBlockState<?> iblockstate, Comparable<?> comparable) {
+            HashMap hashmap = Maps.newHashMap(this.b);
+
+            hashmap.put(iblockstate, comparable);
+            return hashmap;
+        }
+
+        public Material getMaterial() {
+            return this.a.q(this);
+        }
+
+        public boolean b() {
+            return this.a.l(this);
+        }
+
+        public int c() {
+            return this.a.m(this);
+        }
+
+        public int d() {
+            return this.a.o(this);
+        }
+
+        public boolean f() {
+            return this.a.p(this);
+        }
+
+        public MaterialMapColor g() {
+            return this.a.r(this);
+        }
+
+        public IBlockData a(EnumBlockRotation enumblockrotation) {
+            return this.a.a((IBlockData) this, enumblockrotation);
+        }
+
+        public IBlockData a(EnumBlockMirror enumblockmirror) {
+            return this.a.a((IBlockData) this, enumblockmirror);
+        }
+
+        public boolean h() {
+            return this.a.c((IBlockData) this);
+        }
+
+        public EnumRenderType i() {
+            return this.a.a((IBlockData) this);
+        }
+
+        public boolean k() {
+            return this.a.s(this);
+        }
+
+        public boolean l() {
+            return this.a.isOccluding(this);
+        }
+
+        public boolean m() {
+            return this.a.isPowerSource(this);
+        }
+
+        public int a(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+            return this.a.b((IBlockData) this, iblockaccess, blockposition, enumdirection);
+        }
+
+        public boolean n() {
+            return this.a.isComplexRedstone(this);
+        }
+
+        public int a(World world, BlockPosition blockposition) {
+            return this.a.d(this, world, blockposition);
+        }
+
+        public float b(World world, BlockPosition blockposition) {
+            return this.a.b(this, world, blockposition);
+        }
+
+        public float a(EntityHuman entityhuman, World world, BlockPosition blockposition) {
+            return this.a.getDamage(this, entityhuman, world, blockposition);
+        }
+
+        public int b(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+            return this.a.c(this, iblockaccess, blockposition, enumdirection);
+        }
+
+        public EnumPistonReaction o() {
+            return this.a.h(this);
+        }
+
+        public IBlockData b(IBlockAccess iblockaccess, BlockPosition blockposition) {
+            return this.a.updateState(this, iblockaccess, blockposition);
+        }
+
+        public boolean p() {
+            return this.a.b((IBlockData) this);
+        }
+
+        public AxisAlignedBB d(World world, BlockPosition blockposition) {
+            return this.a.a((IBlockData) this, world, blockposition);
+        }
+
+        public void a(World world, BlockPosition blockposition, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+            this.a.a((IBlockData) this, world, blockposition, axisalignedbb, list, entity);
+        }
+
+        public AxisAlignedBB c(IBlockAccess iblockaccess, BlockPosition blockposition) {
+            return this.a.a((IBlockData) this, iblockaccess, blockposition);
+        }
+
+        public MovingObjectPosition a(World world, BlockPosition blockposition, Vec3D vec3d, Vec3D vec3d1) {
+            return this.a.a(this, world, blockposition, vec3d, vec3d1);
+        }
+
+        public boolean q() {
+            return this.a.k(this);
+        }
+
+        BlockData(Block block, ImmutableMap immutablemap, Object object) {
+            this(block, immutablemap);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PersistentVillage.java b/src/main/java/net/minecraft/server/PersistentVillage.java
new file mode 100644
index 0000000..107f582
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PersistentVillage.java
@@ -0,0 +1,266 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+
+public class PersistentVillage extends PersistentBase {
+
+    private World world;
+    private final List<BlockPosition> c = Lists.newArrayList();
+    private final List<VillageDoor> d = Lists.newArrayList();
+    private final List<Village> villages = Lists.newArrayList();
+    private int time;
+
+    public PersistentVillage(String s) {
+        super(s);
+    }
+
+    public PersistentVillage(World world) {
+        super(a(world.worldProvider));
+        this.world = world;
+        this.c();
+    }
+
+    public void a(World world) {
+        this.world = world;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(world);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition) {
+        if (this.c.size() <= 64) {
+            if (!this.e(blockposition)) {
+                this.c.add(blockposition);
+            }
+
+        }
+    }
+
+    public void tick() {
+        ++this.time;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(this.time);
+        }
+
+        this.e();
+        this.f();
+        this.g();
+        if (this.time % 400 == 0) {
+            this.c();
+        }
+
+    }
+
+    private void e() {
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            if (village.g()) {
+                iterator.remove();
+                this.c();
+            }
+        }
+
+    }
+
+    public List<Village> getVillages() {
+        return this.villages;
+    }
+
+    public Village getClosestVillage(BlockPosition blockposition, int i) {
+        Village village = null;
+        double d0 = 3.4028234663852886E38D;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village1 = (Village) iterator.next();
+            double d1 = village1.a().k(blockposition);
+
+            if (d1 < d0) {
+                float f = (float) (i + village1.b());
+
+                if (d1 <= (double) (f * f)) {
+                    village = village1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return village;
+    }
+
+    private void f() {
+        if (!this.c.isEmpty()) {
+            this.b((BlockPosition) this.c.remove(0));
+        }
+    }
+
+    private void g() {
+        for (int i = 0; i < this.d.size(); ++i) {
+            VillageDoor villagedoor = (VillageDoor) this.d.get(i);
+            Village village = this.getClosestVillage(villagedoor.d(), 32);
+
+            if (village == null) {
+                village = new Village(this.world);
+                this.villages.add(village);
+                this.c();
+            }
+
+            village.a(villagedoor);
+        }
+
+        this.d.clear();
+    }
+
+    private void b(BlockPosition blockposition) {
+        byte b0 = 16;
+        byte b1 = 4;
+        byte b2 = 16;
+
+        for (int i = -b0; i < b0; ++i) {
+            for (int j = -b1; j < b1; ++j) {
+                for (int k = -b2; k < b2; ++k) {
+                    BlockPosition blockposition1 = blockposition.a(i, j, k);
+
+                    if (this.f(blockposition1)) {
+                        VillageDoor villagedoor = this.c(blockposition1);
+
+                        if (villagedoor == null) {
+                            this.d(blockposition1);
+                        } else {
+                            villagedoor.a(this.time);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    private VillageDoor c(BlockPosition blockposition) {
+        Iterator iterator = this.d.iterator();
+
+        VillageDoor villagedoor;
+
+        do {
+            if (!iterator.hasNext()) {
+                iterator = this.villages.iterator();
+
+                VillageDoor villagedoor1;
+
+                do {
+                    if (!iterator.hasNext()) {
+                        return null;
+                    }
+
+                    Village village = (Village) iterator.next();
+
+                    villagedoor1 = village.e(blockposition);
+                } while (villagedoor1 == null);
+
+                return villagedoor1;
+            }
+
+            villagedoor = (VillageDoor) iterator.next();
+        } while (villagedoor.d().getX() != blockposition.getX() || villagedoor.d().getZ() != blockposition.getZ() || Math.abs(villagedoor.d().getY() - blockposition.getY()) > 1);
+
+        return villagedoor;
+    }
+
+    private void d(BlockPosition blockposition) {
+        EnumDirection enumdirection = BlockDoor.f(this.world, blockposition);
+        EnumDirection enumdirection1 = enumdirection.opposite();
+        int i = this.a(blockposition, enumdirection, 5);
+        int j = this.a(blockposition, enumdirection1, i + 1);
+
+        if (i != j) {
+            this.d.add(new VillageDoor(blockposition, i < j ? enumdirection : enumdirection1, this.time));
+        }
+
+    }
+
+    private int a(BlockPosition blockposition, EnumDirection enumdirection, int i) {
+        int j = 0;
+
+        for (int k = 1; k <= 5; ++k) {
+            if (this.world.h(blockposition.shift(enumdirection, k))) {
+                ++j;
+                if (j >= i) {
+                    return j;
+                }
+            }
+        }
+
+        return j;
+    }
+
+    private boolean e(BlockPosition blockposition) {
+        Iterator iterator = this.c.iterator();
+
+        BlockPosition blockposition1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            blockposition1 = (BlockPosition) iterator.next();
+        } while (!blockposition1.equals(blockposition));
+
+        return true;
+    }
+
+    private boolean f(BlockPosition blockposition) {
+        IBlockData iblockdata = this.world.getType(blockposition);
+        Block block = iblockdata.getBlock();
+
+        return block instanceof BlockDoor ? iblockdata.getMaterial() == Material.WOOD : false;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        this.time = nbttagcompound.getInt("Tick");
+        NBTTagList nbttaglist = nbttagcompound.getList("Villages", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.get(i);
+            Village village = new Village();
+
+            village.a(nbttagcompound1);
+            this.villages.add(village);
+        }
+
+    }
+
+    public void b(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("Tick", this.time);
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            village.b(nbttagcompound1);
+            nbttaglist.add(nbttagcompound1);
+        }
+
+        nbttagcompound.set("Villages", nbttaglist);
+    }
+
+    public static String a(WorldProvider worldprovider) {
+        return "villages" + worldprovider.getDimensionManager().c();
+    }
+}
-- 
2.5.0
