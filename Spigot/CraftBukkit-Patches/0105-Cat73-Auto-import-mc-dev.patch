From 641e5da0897e48383bdee1daf109ea00dea39eb5 Mon Sep 17 00:00:00 2001
From: Cat73 <root@cat73.org>
Date: Wed, 26 Feb 2020 13:55:25 +0800
Subject: [PATCH] Cat73 -> Auto import mc-dev


diff --git a/src/main/java/net/minecraft/server/BaseBlockPosition.java b/src/main/java/net/minecraft/server/BaseBlockPosition.java
new file mode 100644
index 00000000..a3b5793e
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BaseBlockPosition.java
@@ -0,0 +1,111 @@
+package net.minecraft.server;
+
+import com.google.common.base.MoreObjects;
+import javax.annotation.concurrent.Immutable;
+
+@Immutable
+public class BaseBlockPosition implements Comparable<BaseBlockPosition> {
+
+    public static final BaseBlockPosition ZERO = new BaseBlockPosition(0, 0, 0);
+    @Deprecated
+    private final int a;
+    @Deprecated
+    private final int b;
+    @Deprecated
+    private final int c;
+
+    public BaseBlockPosition(int i, int j, int k) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+    }
+
+    public BaseBlockPosition(double d0, double d1, double d2) {
+        this(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof BaseBlockPosition)) {
+            return false;
+        } else {
+            BaseBlockPosition baseblockposition = (BaseBlockPosition) object;
+
+            return this.getX() != baseblockposition.getX() ? false : (this.getY() != baseblockposition.getY() ? false : this.getZ() == baseblockposition.getZ());
+        }
+    }
+
+    public int hashCode() {
+        return (this.getY() + this.getZ() * 31) * 31 + this.getX();
+    }
+
+    public int compareTo(BaseBlockPosition baseblockposition) {
+        return this.getY() == baseblockposition.getY() ? (this.getZ() == baseblockposition.getZ() ? this.getX() - baseblockposition.getX() : this.getZ() - baseblockposition.getZ()) : this.getY() - baseblockposition.getY();
+    }
+
+    public int getX() {
+        return this.a;
+    }
+
+    public int getY() {
+        return this.b;
+    }
+
+    public int getZ() {
+        return this.c;
+    }
+
+    public BaseBlockPosition down() {
+        return this.down(1);
+    }
+
+    public BaseBlockPosition down(int i) {
+        return this.shift(EnumDirection.DOWN, i);
+    }
+
+    public BaseBlockPosition shift(EnumDirection enumdirection, int i) {
+        return i == 0 ? this : new BaseBlockPosition(this.getX() + enumdirection.getAdjacentX() * i, this.getY() + enumdirection.getAdjacentY() * i, this.getZ() + enumdirection.getAdjacentZ() * i);
+    }
+
+    public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+        return new BaseBlockPosition(this.getY() * baseblockposition.getZ() - this.getZ() * baseblockposition.getY(), this.getZ() * baseblockposition.getX() - this.getX() * baseblockposition.getZ(), this.getX() * baseblockposition.getY() - this.getY() * baseblockposition.getX());
+    }
+
+    public boolean a(BaseBlockPosition baseblockposition, double d0) {
+        return this.distanceSquared((double) baseblockposition.getX(), (double) baseblockposition.getY(), (double) baseblockposition.getZ(), false) < d0 * d0;
+    }
+
+    public boolean a(IPosition iposition, double d0) {
+        return this.distanceSquared(iposition.getX(), iposition.getY(), iposition.getZ(), true) < d0 * d0;
+    }
+
+    public double m(BaseBlockPosition baseblockposition) {
+        return this.distanceSquared((double) baseblockposition.getX(), (double) baseblockposition.getY(), (double) baseblockposition.getZ(), true);
+    }
+
+    public double a(IPosition iposition, boolean flag) {
+        return this.distanceSquared(iposition.getX(), iposition.getY(), iposition.getZ(), flag);
+    }
+
+    public double distanceSquared(double d0, double d1, double d2, boolean flag) {
+        double d3 = flag ? 0.5D : 0.0D;
+        double d4 = (double) this.getX() + d3 - d0;
+        double d5 = (double) this.getY() + d3 - d1;
+        double d6 = (double) this.getZ() + d3 - d2;
+
+        return d4 * d4 + d5 * d5 + d6 * d6;
+    }
+
+    public int n(BaseBlockPosition baseblockposition) {
+        float f = (float) Math.abs(baseblockposition.getX() - this.getX());
+        float f1 = (float) Math.abs(baseblockposition.getY() - this.getY());
+        float f2 = (float) Math.abs(baseblockposition.getZ() - this.getZ());
+
+        return (int) (f + f1 + f2);
+    }
+
+    public String toString() {
+        return MoreObjects.toStringHelper(this).add("x", this.getX()).add("y", this.getY()).add("z", this.getZ()).toString();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
new file mode 100644
index 00000000..65206775
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -0,0 +1,147 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public class ChunkSection {
+
+    public static final DataPalette<IBlockData> GLOBAL_PALETTE = new DataPaletteGlobal<>(Block.REGISTRY_ID, Blocks.AIR.getBlockData());
+    private final int yPos;
+    private short nonEmptyBlockCount;
+    private short tickingBlockCount;
+    private short e;
+    private final DataPaletteBlock<IBlockData> blockIds;
+
+    public ChunkSection(int i) {
+        this(i, (short) 0, (short) 0, (short) 0);
+    }
+
+    public ChunkSection(int i, short short0, short short1, short short2) {
+        this.yPos = i;
+        this.nonEmptyBlockCount = short0;
+        this.tickingBlockCount = short1;
+        this.e = short2;
+        this.blockIds = new DataPaletteBlock<>(ChunkSection.GLOBAL_PALETTE, Block.REGISTRY_ID, GameProfileSerializer::d, GameProfileSerializer::a, Blocks.AIR.getBlockData());
+    }
+
+    public IBlockData getType(int i, int j, int k) {
+        return (IBlockData) this.blockIds.a(i, j, k);
+    }
+
+    public Fluid b(int i, int j, int k) {
+        return ((IBlockData) this.blockIds.a(i, j, k)).getFluid();
+    }
+
+    public void a() {
+        this.blockIds.a();
+    }
+
+    public void b() {
+        this.blockIds.b();
+    }
+
+    public IBlockData setType(int i, int j, int k, IBlockData iblockdata) {
+        return this.setType(i, j, k, iblockdata, true);
+    }
+
+    public IBlockData setType(int i, int j, int k, IBlockData iblockdata, boolean flag) {
+        IBlockData iblockdata1;
+
+        if (flag) {
+            iblockdata1 = (IBlockData) this.blockIds.setBlock(i, j, k, iblockdata);
+        } else {
+            iblockdata1 = (IBlockData) this.blockIds.b(i, j, k, iblockdata);
+        }
+
+        Fluid fluid = iblockdata1.getFluid();
+        Fluid fluid1 = iblockdata.getFluid();
+
+        if (!iblockdata1.isAir()) {
+            --this.nonEmptyBlockCount;
+            if (iblockdata1.q()) {
+                --this.tickingBlockCount;
+            }
+        }
+
+        if (!fluid.isEmpty()) {
+            --this.e;
+        }
+
+        if (!iblockdata.isAir()) {
+            ++this.nonEmptyBlockCount;
+            if (iblockdata.q()) {
+                ++this.tickingBlockCount;
+            }
+        }
+
+        if (!fluid1.isEmpty()) {
+            ++this.e;
+        }
+
+        return iblockdata1;
+    }
+
+    public boolean c() {
+        return this.nonEmptyBlockCount == 0;
+    }
+
+    public static boolean a(@Nullable ChunkSection chunksection) {
+        return chunksection == Chunk.a || chunksection.c();
+    }
+
+    public boolean d() {
+        return this.shouldTick() || this.f();
+    }
+
+    public boolean shouldTick() {
+        return this.tickingBlockCount > 0;
+    }
+
+    public boolean f() {
+        return this.e > 0;
+    }
+
+    public int getYPosition() {
+        return this.yPos;
+    }
+
+    public void recalcBlockCounts() {
+        this.nonEmptyBlockCount = 0;
+        this.tickingBlockCount = 0;
+        this.e = 0;
+        this.blockIds.a((iblockdata, i) -> {
+            Fluid fluid = iblockdata.getFluid();
+
+            if (!iblockdata.isAir()) {
+                this.nonEmptyBlockCount = (short) (this.nonEmptyBlockCount + i);
+                if (iblockdata.q()) {
+                    this.tickingBlockCount = (short) (this.tickingBlockCount + i);
+                }
+            }
+
+            if (!fluid.isEmpty()) {
+                this.nonEmptyBlockCount = (short) (this.nonEmptyBlockCount + i);
+                if (fluid.h()) {
+                    this.e = (short) (this.e + i);
+                }
+            }
+
+        });
+    }
+
+    public DataPaletteBlock<IBlockData> getBlocks() {
+        return this.blockIds;
+    }
+
+    public void b(PacketDataSerializer packetdataserializer) {
+        packetdataserializer.writeShort(this.nonEmptyBlockCount);
+        this.blockIds.b(packetdataserializer);
+    }
+
+    public int j() {
+        return 2 + this.blockIds.c();
+    }
+
+    public boolean a(IBlockData iblockdata) {
+        return this.blockIds.contains(iblockdata);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
new file mode 100644
index 00000000..7ca3a1d0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -0,0 +1,129 @@
+package net.minecraft.server;
+
+import java.util.function.IntConsumer;
+import org.apache.commons.lang3.Validate;
+
+public class DataBits {
+
+    private final long[] a;
+    private final int b;
+    private final long c;
+    private final int d;
+
+    public DataBits(int i, int j) {
+        this(i, j, new long[MathHelper.c(j * i, 64) / 64]);
+    }
+
+    public DataBits(int i, int j, long[] along) {
+        Validate.inclusiveBetween(1L, 32L, (long) i);
+        this.d = j;
+        this.b = i;
+        this.a = along;
+        this.c = (1L << i) - 1L;
+        int k = MathHelper.c(j * i, 64) / 64;
+
+        if (along.length != k) {
+            throw (RuntimeException) SystemUtils.c(new RuntimeException("Invalid length given for storage, got: " + along.length + " but expected: " + k));
+        }
+    }
+
+    public int a(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.c, (long) j);
+        int k = i * this.b;
+        int l = k >> 6;
+        int i1 = (i + 1) * this.b - 1 >> 6;
+        int j1 = k ^ l << 6;
+        byte b0 = 0;
+        int k1 = b0 | (int) (this.a[l] >>> j1 & this.c);
+
+        this.a[l] = this.a[l] & ~(this.c << j1) | ((long) j & this.c) << j1;
+        if (l != i1) {
+            int l1 = 64 - j1;
+            int i2 = this.b - l1;
+
+            k1 |= (int) (this.a[i1] << l1 & this.c);
+            this.a[i1] = this.a[i1] >>> i2 << i2 | ((long) j & this.c) >> l1;
+        }
+
+        return k1;
+    }
+
+    public void b(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.c, (long) j);
+        int k = i * this.b;
+        int l = k >> 6;
+        int i1 = (i + 1) * this.b - 1 >> 6;
+        int j1 = k ^ l << 6;
+
+        this.a[l] = this.a[l] & ~(this.c << j1) | ((long) j & this.c) << j1;
+        if (l != i1) {
+            int k1 = 64 - j1;
+            int l1 = this.b - k1;
+
+            this.a[i1] = this.a[i1] >>> l1 << l1 | ((long) j & this.c) >> k1;
+        }
+
+    }
+
+    public int a(int i) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        int j = i * this.b;
+        int k = j >> 6;
+        int l = (i + 1) * this.b - 1 >> 6;
+        int i1 = j ^ k << 6;
+
+        if (k == l) {
+            return (int) (this.a[k] >>> i1 & this.c);
+        } else {
+            int j1 = 64 - i1;
+
+            return (int) ((this.a[k] >>> i1 | this.a[l] << j1) & this.c);
+        }
+    }
+
+    public long[] a() {
+        return this.a;
+    }
+
+    public int b() {
+        return this.d;
+    }
+
+    public int c() {
+        return this.b;
+    }
+
+    public void a(IntConsumer intconsumer) {
+        int i = this.a.length;
+
+        if (i != 0) {
+            int j = 0;
+            long k = this.a[0];
+            long l = i > 1 ? this.a[1] : 0L;
+
+            for (int i1 = 0; i1 < this.d; ++i1) {
+                int j1 = i1 * this.b;
+                int k1 = j1 >> 6;
+                int l1 = (i1 + 1) * this.b - 1 >> 6;
+                int i2 = j1 ^ k1 << 6;
+
+                if (k1 != j) {
+                    k = l;
+                    l = k1 + 1 < i ? this.a[k1 + 1] : 0L;
+                    j = k1;
+                }
+
+                if (k1 == l1) {
+                    intconsumer.accept((int) (k >>> i2 & this.c));
+                } else {
+                    int j2 = 64 - i2;
+
+                    intconsumer.accept((int) ((k >>> i2 | l << j2) & this.c));
+                }
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RegistryMaterials.java b/src/main/java/net/minecraft/server/RegistryMaterials.java
new file mode 100644
index 00000000..2d6a7b3a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RegistryMaterials.java
@@ -0,0 +1,106 @@
+package net.minecraft.server;
+
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.Optional;
+import java.util.Random;
+import java.util.Set;
+import javax.annotation.Nullable;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class RegistryMaterials<T> extends IRegistryWritable<T> {
+
+    protected static final Logger LOGGER = LogManager.getLogger();
+    protected final RegistryID<T> b = new RegistryID<>(256);
+    protected final BiMap<MinecraftKey, T> c = HashBiMap.create();
+    protected Object[] d;
+    private int V;
+
+    public RegistryMaterials() {}
+
+    @Override
+    public <V extends T> V a(int i, MinecraftKey minecraftkey, V v0) {
+        this.b.a(v0, i);
+        Validate.notNull(minecraftkey);
+        Validate.notNull(v0);
+        this.d = null;
+        if (this.c.containsKey(minecraftkey)) {
+            RegistryMaterials.LOGGER.debug("Adding duplicate key '{}' to registry", minecraftkey);
+        }
+
+        this.c.put(minecraftkey, v0);
+        if (this.V <= i) {
+            this.V = i + 1;
+        }
+
+        return v0;
+    }
+
+    @Override
+    public <V extends T> V a(MinecraftKey minecraftkey, V v0) {
+        return this.a(this.V, minecraftkey, v0);
+    }
+
+    @Nullable
+    @Override
+    public MinecraftKey getKey(T t0) {
+        return (MinecraftKey) this.c.inverse().get(t0);
+    }
+
+    @Override
+    public int a(@Nullable T t0) {
+        return this.b.getId(t0);
+    }
+
+    @Nullable
+    @Override
+    public T fromId(int i) {
+        return this.b.fromId(i);
+    }
+
+    public Iterator<T> iterator() {
+        return this.b.iterator();
+    }
+
+    @Nullable
+    @Override
+    public T get(@Nullable MinecraftKey minecraftkey) {
+        return this.c.get(minecraftkey);
+    }
+
+    @Override
+    public Optional<T> getOptional(@Nullable MinecraftKey minecraftkey) {
+        return Optional.ofNullable(this.c.get(minecraftkey));
+    }
+
+    @Override
+    public Set<MinecraftKey> keySet() {
+        return Collections.unmodifiableSet(this.c.keySet());
+    }
+
+    @Override
+    public boolean c() {
+        return this.c.isEmpty();
+    }
+
+    @Nullable
+    @Override
+    public T a(Random random) {
+        if (this.d == null) {
+            Collection<?> collection = this.c.values();
+
+            if (collection.isEmpty()) {
+                return null;
+            }
+
+            this.d = collection.toArray(new Object[collection.size()]);
+        }
+
+        return this.d[random.nextInt(this.d.length)];
+    }
+}
-- 
2.25.0

