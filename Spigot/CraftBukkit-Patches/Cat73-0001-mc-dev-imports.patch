From 904cf475635d450be360cb181e0e4fb6d0a19670 Mon Sep 17 00:00:00 2001
From: Cat73 <1901803382@qq.com>
Date: Fri, 19 Mar 2016 14:12:20 +0800
Subject: [PATCH] Cat73 -> mc-dev imports

这里的所有代码均应该直接从 MC 反编译结果里复制，并且不应做任何修改，任何 patch 都应该在其他文件里实现。
增加文件前请先检查 0003-mc-dev-imports.patch 里有无该文件，如果有则不应再在这里添加。
MC 版本没有更变的情况下，这里的东西都不需要变，但是 MC 版本更变如 1.9 -> 1.9.1，那就需要检查下这里的文件是否有变化。
Link：https://github.com/PaperMC/Paper/blob/master/Spigot-Server-Patches/0003-mc-dev-imports.patch

diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
new file mode 100644
index 0000000..e7a95f3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -0,0 +1,381 @@
+package net.minecraft.server;
+
+import com.google.common.collect.AbstractIterator;
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class BlockPosition extends BaseBlockPosition {
+
+    private static final Logger c = LogManager.getLogger();
+    public static final BlockPosition ZERO = new BlockPosition(0, 0, 0);
+    private static final int d = 1 + MathHelper.e(MathHelper.c(30000000));
+    private static final int e = BlockPosition.d;
+    private static final int f = 64 - BlockPosition.d - BlockPosition.e;
+    private static final int g = 0 + BlockPosition.e;
+    private static final int h = BlockPosition.g + BlockPosition.f;
+    private static final long i = (1L << BlockPosition.d) - 1L;
+    private static final long j = (1L << BlockPosition.f) - 1L;
+    private static final long k = (1L << BlockPosition.e) - 1L;
+
+    public BlockPosition(int i, int j, int k) {
+        super(i, j, k);
+    }
+
+    public BlockPosition(double d0, double d1, double d2) {
+        super(d0, d1, d2);
+    }
+
+    public BlockPosition(Entity entity) {
+        this(entity.locX, entity.locY, entity.locZ);
+    }
+
+    public BlockPosition(Vec3D vec3d) {
+        this(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public BlockPosition(BaseBlockPosition baseblockposition) {
+        this(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public BlockPosition a(double d0, double d1, double d2) {
+        return d0 == 0.0D && d1 == 0.0D && d2 == 0.0D ? this : new BlockPosition((double) this.getX() + d0, (double) this.getY() + d1, (double) this.getZ() + d2);
+    }
+
+    public BlockPosition a(int i, int j, int k) {
+        return i == 0 && j == 0 && k == 0 ? this : new BlockPosition(this.getX() + i, this.getY() + j, this.getZ() + k);
+    }
+
+    public BlockPosition a(BaseBlockPosition baseblockposition) {
+        return baseblockposition.getX() == 0 && baseblockposition.getY() == 0 && baseblockposition.getZ() == 0 ? this : new BlockPosition(this.getX() + baseblockposition.getX(), this.getY() + baseblockposition.getY(), this.getZ() + baseblockposition.getZ());
+    }
+
+    public BlockPosition b(BaseBlockPosition baseblockposition) {
+        return baseblockposition.getX() == 0 && baseblockposition.getY() == 0 && baseblockposition.getZ() == 0 ? this : new BlockPosition(this.getX() - baseblockposition.getX(), this.getY() - baseblockposition.getY(), this.getZ() - baseblockposition.getZ());
+    }
+
+    public BlockPosition up() {
+        return this.up(1);
+    }
+
+    public BlockPosition up(int i) {
+        return this.shift(EnumDirection.UP, i);
+    }
+
+    public BlockPosition down() {
+        return this.down(1);
+    }
+
+    public BlockPosition down(int i) {
+        return this.shift(EnumDirection.DOWN, i);
+    }
+
+    public BlockPosition north() {
+        return this.north(1);
+    }
+
+    public BlockPosition north(int i) {
+        return this.shift(EnumDirection.NORTH, i);
+    }
+
+    public BlockPosition south() {
+        return this.south(1);
+    }
+
+    public BlockPosition south(int i) {
+        return this.shift(EnumDirection.SOUTH, i);
+    }
+
+    public BlockPosition west() {
+        return this.west(1);
+    }
+
+    public BlockPosition west(int i) {
+        return this.shift(EnumDirection.WEST, i);
+    }
+
+    public BlockPosition east() {
+        return this.east(1);
+    }
+
+    public BlockPosition east(int i) {
+        return this.shift(EnumDirection.EAST, i);
+    }
+
+    public BlockPosition shift(EnumDirection enumdirection) {
+        return this.shift(enumdirection, 1);
+    }
+
+    public BlockPosition shift(EnumDirection enumdirection, int i) {
+        return i == 0 ? this : new BlockPosition(this.getX() + enumdirection.getAdjacentX() * i, this.getY() + enumdirection.getAdjacentY() * i, this.getZ() + enumdirection.getAdjacentZ() * i);
+    }
+
+    public BlockPosition c(BaseBlockPosition baseblockposition) {
+        return new BlockPosition(this.getY() * baseblockposition.getZ() - this.getZ() * baseblockposition.getY(), this.getZ() * baseblockposition.getX() - this.getX() * baseblockposition.getZ(), this.getX() * baseblockposition.getY() - this.getY() * baseblockposition.getX());
+    }
+
+    public long asLong() {
+        return ((long) this.getX() & BlockPosition.i) << BlockPosition.h | ((long) this.getY() & BlockPosition.j) << BlockPosition.g | ((long) this.getZ() & BlockPosition.k) << 0;
+    }
+
+    public static BlockPosition fromLong(long i) {
+        int j = (int) (i << 64 - BlockPosition.h - BlockPosition.d >> 64 - BlockPosition.d);
+        int k = (int) (i << 64 - BlockPosition.g - BlockPosition.f >> 64 - BlockPosition.f);
+        int l = (int) (i << 64 - BlockPosition.e >> 64 - BlockPosition.e);
+
+        return new BlockPosition(j, k, l);
+    }
+
+    public static Iterable<BlockPosition> a(BlockPosition blockposition, BlockPosition blockposition1) {
+        final BlockPosition blockposition2 = new BlockPosition(Math.min(blockposition.getX(), blockposition1.getX()), Math.min(blockposition.getY(), blockposition1.getY()), Math.min(blockposition.getZ(), blockposition1.getZ()));
+        final BlockPosition blockposition3 = new BlockPosition(Math.max(blockposition.getX(), blockposition1.getX()), Math.max(blockposition.getY(), blockposition1.getY()), Math.max(blockposition.getZ(), blockposition1.getZ()));
+
+        return new Iterable() {
+            public Iterator<BlockPosition> iterator() {
+                return new AbstractIterator() {
+                    private BlockPosition b = null;
+
+                    protected BlockPosition a() {
+                        if (this.b == null) {
+                            this.b = blockposition2;
+                            return this.b;
+                        } else if (this.b.equals(blockposition3)) {
+                            return (BlockPosition) this.endOfData();
+                        } else {
+                            int i = this.b.getX();
+                            int j = this.b.getY();
+                            int k = this.b.getZ();
+
+                            if (i < blockposition3.getX()) {
+                                ++i;
+                            } else if (j < blockposition3.getY()) {
+                                i = blockposition2.getX();
+                                ++j;
+                            } else if (k < blockposition3.getZ()) {
+                                i = blockposition2.getX();
+                                j = blockposition2.getY();
+                                ++k;
+                            }
+
+                            this.b = new BlockPosition(i, j, k);
+                            return this.b;
+                        }
+                    }
+
+                    protected Object computeNext() {
+                        return this.a();
+                    }
+                };
+            }
+        };
+    }
+
+    public BlockPosition h() {
+        return this;
+    }
+
+    public static Iterable<BlockPosition.MutableBlockPosition> b(BlockPosition blockposition, BlockPosition blockposition1) {
+        final BlockPosition blockposition2 = new BlockPosition(Math.min(blockposition.getX(), blockposition1.getX()), Math.min(blockposition.getY(), blockposition1.getY()), Math.min(blockposition.getZ(), blockposition1.getZ()));
+        final BlockPosition blockposition3 = new BlockPosition(Math.max(blockposition.getX(), blockposition1.getX()), Math.max(blockposition.getY(), blockposition1.getY()), Math.max(blockposition.getZ(), blockposition1.getZ()));
+
+        return new Iterable() {
+            public Iterator<BlockPosition.MutableBlockPosition> iterator() {
+                return new AbstractIterator() {
+                    private BlockPosition.MutableBlockPosition b = null;
+
+                    protected BlockPosition.MutableBlockPosition a() {
+                        if (this.b == null) {
+                            this.b = new BlockPosition.MutableBlockPosition(blockposition2.getX(), blockposition2.getY(), blockposition2.getZ());
+                            return this.b;
+                        } else if (this.b.equals(blockposition3)) {
+                            return (BlockPosition.MutableBlockPosition) this.endOfData();
+                        } else {
+                            int i = this.b.getX();
+                            int j = this.b.getY();
+                            int k = this.b.getZ();
+
+                            if (i < blockposition3.getX()) {
+                                ++i;
+                            } else if (j < blockposition3.getY()) {
+                                i = blockposition2.getX();
+                                ++j;
+                            } else if (k < blockposition3.getZ()) {
+                                i = blockposition2.getX();
+                                j = blockposition2.getY();
+                                ++k;
+                            }
+
+                            this.b.c = i;
+                            this.b.d = j;
+                            this.b.e = k;
+                            return this.b;
+                        }
+                    }
+
+                    protected Object computeNext() {
+                        return this.a();
+                    }
+                };
+            }
+        };
+    }
+
+    public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+        return this.c(baseblockposition);
+    }
+
+    public static final class PooledBlockPosition extends BlockPosition {
+
+        private int c;
+        private int d;
+        private int e;
+        private boolean f;
+        private static final List<BlockPosition.PooledBlockPosition> g = Lists.newArrayList();
+
+        private PooledBlockPosition(int i, int j, int k) {
+            super(0, 0, 0);
+            this.c = i;
+            this.d = j;
+            this.e = k;
+        }
+
+        public static BlockPosition.PooledBlockPosition s() {
+            return c(0, 0, 0);
+        }
+
+        public static BlockPosition.PooledBlockPosition c(double d0, double d1, double d2) {
+            return c(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+        }
+
+        public static BlockPosition.PooledBlockPosition c(int i, int j, int k) {
+            List list = BlockPosition.PooledBlockPosition.g;
+
+            synchronized (BlockPosition.PooledBlockPosition.g) {
+                if (!BlockPosition.PooledBlockPosition.g.isEmpty()) {
+                    BlockPosition.PooledBlockPosition blockposition_pooledblockposition = (BlockPosition.PooledBlockPosition) BlockPosition.PooledBlockPosition.g.remove(BlockPosition.PooledBlockPosition.g.size() - 1);
+
+                    if (blockposition_pooledblockposition != null && blockposition_pooledblockposition.f) {
+                        blockposition_pooledblockposition.f = false;
+                        blockposition_pooledblockposition.d(i, j, k);
+                        return blockposition_pooledblockposition;
+                    }
+                }
+            }
+
+            return new BlockPosition.PooledBlockPosition(i, j, k);
+        }
+
+        public void t() {
+            List list = BlockPosition.PooledBlockPosition.g;
+
+            synchronized (BlockPosition.PooledBlockPosition.g) {
+                if (BlockPosition.PooledBlockPosition.g.size() < 100) {
+                    BlockPosition.PooledBlockPosition.g.add(this);
+                }
+
+                this.f = true;
+            }
+        }
+
+        public int getX() {
+            return this.c;
+        }
+
+        public int getY() {
+            return this.d;
+        }
+
+        public int getZ() {
+            return this.e;
+        }
+
+        public BlockPosition.PooledBlockPosition d(int i, int j, int k) {
+            if (this.f) {
+                BlockPosition.c.error("PooledMutableBlockPosition modified after it was released.", new Throwable());
+                this.f = false;
+            }
+
+            this.c = i;
+            this.d = j;
+            this.e = k;
+            return this;
+        }
+
+        public BlockPosition.PooledBlockPosition d(double d0, double d1, double d2) {
+            return this.d(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+        }
+
+        public BlockPosition.PooledBlockPosition h(BaseBlockPosition baseblockposition) {
+            return this.d(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+        }
+
+        public BlockPosition.PooledBlockPosition c(EnumDirection enumdirection) {
+            return this.d(this.c + enumdirection.getAdjacentX(), this.d + enumdirection.getAdjacentY(), this.e + enumdirection.getAdjacentZ());
+        }
+
+        public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+            return super.c(baseblockposition);
+        }
+    }
+
+    public static final class MutableBlockPosition extends BlockPosition {
+
+        private int c;
+        private int d;
+        private int e;
+
+        public MutableBlockPosition() {
+            this(0, 0, 0);
+        }
+
+        public MutableBlockPosition(BlockPosition blockposition) {
+            this(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+        }
+
+        public MutableBlockPosition(int i, int j, int k) {
+            super(0, 0, 0);
+            this.c = i;
+            this.d = j;
+            this.e = k;
+        }
+
+        public int getX() {
+            return this.c;
+        }
+
+        public int getY() {
+            return this.d;
+        }
+
+        public int getZ() {
+            return this.e;
+        }
+
+        public BlockPosition.MutableBlockPosition c(int i, int j, int k) {
+            this.c = i;
+            this.d = j;
+            this.e = k;
+            return this;
+        }
+
+        public void c(EnumDirection enumdirection) {
+            this.c += enumdirection.getAdjacentX();
+            this.d += enumdirection.getAdjacentY();
+            this.e += enumdirection.getAdjacentZ();
+        }
+
+        public void p(int i) {
+            this.d = i;
+        }
+
+        public BlockPosition h() {
+            return new BlockPosition(this);
+        }
+
+        public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+            return super.c(baseblockposition);
+        }
+    }
+}

diff --git a/src/main/java/net/minecraft/server/BaseBlockPosition.java b/src/main/java/net/minecraft/server/BaseBlockPosition.java
new file mode 100644
index 0000000..e54e7b7
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BaseBlockPosition.java
@@ -0,0 +1,93 @@
+package net.minecraft.server;
+
+import com.google.common.base.Objects;
+
+public class BaseBlockPosition implements Comparable<BaseBlockPosition> {
+
+    public static final BaseBlockPosition ZERO = new BaseBlockPosition(0, 0, 0);
+    private final int a;
+    private final int c;
+    private final int d;
+
+    public BaseBlockPosition(int i, int j, int k) {
+        this.a = i;
+        this.c = j;
+        this.d = k;
+    }
+
+    public BaseBlockPosition(double d0, double d1, double d2) {
+        this(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof BaseBlockPosition)) {
+            return false;
+        } else {
+            BaseBlockPosition baseblockposition = (BaseBlockPosition) object;
+
+            return this.getX() != baseblockposition.getX() ? false : (this.getY() != baseblockposition.getY() ? false : this.getZ() == baseblockposition.getZ());
+        }
+    }
+
+    public int hashCode() {
+        return (this.getY() + this.getZ() * 31) * 31 + this.getX();
+    }
+
+    public int i(BaseBlockPosition baseblockposition) {
+        return this.getY() == baseblockposition.getY() ? (this.getZ() == baseblockposition.getZ() ? this.getX() - baseblockposition.getX() : this.getZ() - baseblockposition.getZ()) : this.getY() - baseblockposition.getY();
+    }
+
+    public int getX() {
+        return this.a;
+    }
+
+    public int getY() {
+        return this.c;
+    }
+
+    public int getZ() {
+        return this.d;
+    }
+
+    public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+        return new BaseBlockPosition(this.getY() * baseblockposition.getZ() - this.getZ() * baseblockposition.getY(), this.getZ() * baseblockposition.getX() - this.getX() * baseblockposition.getZ(), this.getX() * baseblockposition.getY() - this.getY() * baseblockposition.getX());
+    }
+
+    public double f(int i, int j, int k) {
+        double d0 = (double) (this.getX() - i);
+        double d1 = (double) (this.getY() - j);
+        double d2 = (double) (this.getZ() - k);
+
+        return Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+    }
+
+    public double distanceSquared(double d0, double d1, double d2) {
+        double d3 = (double) this.getX() - d0;
+        double d4 = (double) this.getY() - d1;
+        double d5 = (double) this.getZ() - d2;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
+    }
+
+    public double f(double d0, double d1, double d2) {
+        double d3 = (double) this.getX() + 0.5D - d0;
+        double d4 = (double) this.getY() + 0.5D - d1;
+        double d5 = (double) this.getZ() + 0.5D - d2;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
+    }
+
+    public double k(BaseBlockPosition baseblockposition) {
+        return this.distanceSquared((double) baseblockposition.getX(), (double) baseblockposition.getY(), (double) baseblockposition.getZ());
+    }
+
+    public String toString() {
+        return Objects.toStringHelper(this).add("x", this.getX()).add("y", this.getY()).add("z", this.getZ()).toString();
+    }
+
+    public int compareTo(BaseBlockPosition object) {
+        return this.i(object);
+    }
+}

diff --git a/src/main/java/net/minecraft/server/BlockStateList.java b/src/main/java/net/minecraft/server/BlockStateList.java
new file mode 100644
index 0000000..a11c62f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockStateList.java
@@ -0,0 +1,325 @@
+package net.minecraft.server;
+
+import com.google.common.base.Function;
+import com.google.common.base.Objects;
+import com.google.common.collect.HashBasedTable;
+import com.google.common.collect.ImmutableCollection;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSortedMap;
+import com.google.common.collect.ImmutableTable;
+import com.google.common.collect.Iterables;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.regex.Pattern;
+
+public class BlockStateList {
+
+    private static final Pattern a = Pattern.compile("^[a-z0-9_]+$");
+    private static final Function<IBlockState<?>, String> b = new Function() {
+        public String a(IBlockState<?> iblockstate) {
+            return iblockstate == null ? "<NULL>" : iblockstate.a();
+        }
+
+        public Object apply(Object object) {
+            return this.a((IBlockState) object);
+        }
+    };
+    private final Block c;
+    private final ImmutableSortedMap<String, IBlockState<?>> d;
+    private final ImmutableList<IBlockData> e;
+
+    public BlockStateList(Block block, IBlockState<?>... aiblockstate) {
+        this.c = block;
+        HashMap hashmap = Maps.newHashMap();
+        IBlockState[] aiblockstate1 = aiblockstate;
+        int i = aiblockstate.length;
+
+        for (int j = 0; j < i; ++j) {
+            IBlockState iblockstate = aiblockstate1[j];
+
+            a(block, iblockstate);
+            hashmap.put(iblockstate.a(), iblockstate);
+        }
+
+        this.d = ImmutableSortedMap.copyOf(hashmap);
+        LinkedHashMap linkedhashmap = Maps.newLinkedHashMap();
+        ArrayList arraylist = Lists.newArrayList();
+        Iterable iterable = IteratorUtils.a(this.e());
+        Iterator iterator = iterable.iterator();
+
+        while (iterator.hasNext()) {
+            List list = (List) iterator.next();
+            Map map = MapGeneratorUtils.b(this.d.values(), list);
+            BlockStateList.BlockData blockstatelist_blockdata = new BlockStateList.BlockData(block, ImmutableMap.copyOf(map), null);
+
+            linkedhashmap.put(map, blockstatelist_blockdata);
+            arraylist.add(blockstatelist_blockdata);
+        }
+
+        iterator = arraylist.iterator();
+
+        while (iterator.hasNext()) {
+            BlockStateList.BlockData blockstatelist_blockdata1 = (BlockStateList.BlockData) iterator.next();
+
+            blockstatelist_blockdata1.a((Map) linkedhashmap);
+        }
+
+        this.e = ImmutableList.copyOf(arraylist);
+    }
+
+    public static <T extends Comparable<T>> String a(Block block, IBlockState<T> iblockstate) {
+        String s = iblockstate.a();
+
+        if (!BlockStateList.a.matcher(s).matches()) {
+            throw new IllegalArgumentException("Block: " + block.getClass() + " has invalidly named property: " + s);
+        } else {
+            for (T t : iblockstate.c()) {
+                String s1 = iblockstate.a(t);
+
+                if (!a.matcher(s1).matches())
+                {
+                    throw new IllegalArgumentException("Block: " + block.getClass() + " has property: " + s + " with invalidly named value: " + s1);
+                }
+            }
+        }
+        return s;
+    }
+
+    public ImmutableList<IBlockData> a() {
+        return this.e;
+    }
+
+    private List<Iterable<Comparable<?>>> e() {
+        ArrayList arraylist = Lists.newArrayList();
+        ImmutableCollection immutablecollection = this.d.values();
+        Iterator iterator = immutablecollection.iterator();
+
+        while (iterator.hasNext()) {
+            IBlockState iblockstate = (IBlockState) iterator.next();
+
+            arraylist.add(iblockstate.c());
+        }
+
+        return arraylist;
+    }
+
+    public IBlockData getBlockData() {
+        return (IBlockData) this.e.get(0);
+    }
+
+    public Block getBlock() {
+        return this.c;
+    }
+
+    public Collection<IBlockState<?>> d() {
+        return this.d.values();
+    }
+
+    public String toString() {
+        return Objects.toStringHelper(this).add("block", Block.REGISTRY.b(this.c)).add("properties", Iterables.transform(this.d.values(), BlockStateList.b)).toString();
+    }
+
+    static class BlockData extends BlockDataAbstract {
+
+        private final Block a;
+        private final ImmutableMap<IBlockState<?>, Comparable<?>> b;
+        private ImmutableTable<IBlockState<?>, Comparable<?>, IBlockData> c;
+
+        private BlockData(Block block, ImmutableMap<IBlockState<?>, Comparable<?>> immutablemap) {
+            this.a = block;
+            this.b = immutablemap;
+        }
+
+        public Collection<IBlockState<?>> r() {
+            return Collections.unmodifiableCollection(this.b.keySet());
+        }
+
+        public <T extends Comparable<T>> T get(IBlockState<T> iblockstate) {
+            if (!this.b.containsKey(iblockstate)) {
+                throw new IllegalArgumentException("Cannot get property " + iblockstate + " as it does not exist in " + this.a.t());
+            } else {
+                return iblockstate.b().cast(this.b.get(iblockstate));
+            }
+        }
+
+        public <T extends Comparable<T>, V extends T> IBlockData set(IBlockState<T> iblockstate, V v0) {
+            if (!this.b.containsKey(iblockstate)) {
+                throw new IllegalArgumentException("Cannot set property " + iblockstate + " as it does not exist in " + this.a.t());
+            } else if (!iblockstate.c().contains(v0)) {
+                throw new IllegalArgumentException("Cannot set property " + iblockstate + " to " + v0 + " on block " + Block.REGISTRY.b(this.a) + ", it is not an allowed value");
+            } else {
+                return (IBlockData) (this.b.get(iblockstate) == v0 ? this : (IBlockData) this.c.get(iblockstate, v0));
+            }
+        }
+
+        public ImmutableMap<IBlockState<?>, Comparable<?>> s() {
+            return this.b;
+        }
+
+        public Block getBlock() {
+            return this.a;
+        }
+
+        public boolean equals(Object object) {
+            return this == object;
+        }
+
+        public int hashCode() {
+            return this.b.hashCode();
+        }
+
+        public void a(Map<Map<IBlockState<?>, Comparable<?>>, BlockStateList.BlockData> map) {
+            if (this.c != null) {
+                throw new IllegalStateException();
+            } else {
+                HashBasedTable hashbasedtable = HashBasedTable.create();
+                Iterator iterator = this.b.entrySet().iterator();
+
+                while (iterator.hasNext()) {
+                    Entry entry = (Entry) iterator.next();
+                    IBlockState iblockstate = (IBlockState) entry.getKey();
+                    Iterator iterator1 = iblockstate.c().iterator();
+
+                    while (iterator1.hasNext()) {
+                        Comparable comparable = (Comparable) iterator1.next();
+
+                        if (comparable != entry.getValue()) {
+                            hashbasedtable.put(iblockstate, comparable, map.get(this.b(iblockstate, comparable)));
+                        }
+                    }
+                }
+
+                this.c = ImmutableTable.copyOf(hashbasedtable);
+            }
+        }
+
+        private Map<IBlockState<?>, Comparable<?>> b(IBlockState<?> iblockstate, Comparable<?> comparable) {
+            HashMap hashmap = Maps.newHashMap(this.b);
+
+            hashmap.put(iblockstate, comparable);
+            return hashmap;
+        }
+
+        public Material getMaterial() {
+            return this.a.q(this);
+        }
+
+        public boolean b() {
+            return this.a.l(this);
+        }
+
+        public int c() {
+            return this.a.m(this);
+        }
+
+        public int d() {
+            return this.a.o(this);
+        }
+
+        public boolean f() {
+            return this.a.p(this);
+        }
+
+        public MaterialMapColor g() {
+            return this.a.r(this);
+        }
+
+        public IBlockData a(EnumBlockRotation enumblockrotation) {
+            return this.a.a((IBlockData) this, enumblockrotation);
+        }
+
+        public IBlockData a(EnumBlockMirror enumblockmirror) {
+            return this.a.a((IBlockData) this, enumblockmirror);
+        }
+
+        public boolean h() {
+            return this.a.c((IBlockData) this);
+        }
+
+        public EnumRenderType i() {
+            return this.a.a((IBlockData) this);
+        }
+
+        public boolean k() {
+            return this.a.s(this);
+        }
+
+        public boolean l() {
+            return this.a.isOccluding(this);
+        }
+
+        public boolean m() {
+            return this.a.isPowerSource(this);
+        }
+
+        public int a(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+            return this.a.b((IBlockData) this, iblockaccess, blockposition, enumdirection);
+        }
+
+        public boolean n() {
+            return this.a.isComplexRedstone(this);
+        }
+
+        public int a(World world, BlockPosition blockposition) {
+            return this.a.d(this, world, blockposition);
+        }
+
+        public float b(World world, BlockPosition blockposition) {
+            return this.a.b(this, world, blockposition);
+        }
+
+        public float a(EntityHuman entityhuman, World world, BlockPosition blockposition) {
+            return this.a.getDamage(this, entityhuman, world, blockposition);
+        }
+
+        public int b(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+            return this.a.c(this, iblockaccess, blockposition, enumdirection);
+        }
+
+        public EnumPistonReaction o() {
+            return this.a.h(this);
+        }
+
+        public IBlockData b(IBlockAccess iblockaccess, BlockPosition blockposition) {
+            return this.a.updateState(this, iblockaccess, blockposition);
+        }
+
+        public boolean p() {
+            return this.a.b((IBlockData) this);
+        }
+
+        public AxisAlignedBB d(World world, BlockPosition blockposition) {
+            return this.a.a((IBlockData) this, world, blockposition);
+        }
+
+        public void a(World world, BlockPosition blockposition, AxisAlignedBB axisalignedbb, List<AxisAlignedBB> list, Entity entity) {
+            this.a.a((IBlockData) this, world, blockposition, axisalignedbb, list, entity);
+        }
+
+        public AxisAlignedBB c(IBlockAccess iblockaccess, BlockPosition blockposition) {
+            return this.a.a((IBlockData) this, iblockaccess, blockposition);
+        }
+
+        public MovingObjectPosition a(World world, BlockPosition blockposition, Vec3D vec3d, Vec3D vec3d1) {
+            return this.a.a(this, world, blockposition, vec3d, vec3d1);
+        }
+
+        public boolean q() {
+            return this.a.k(this);
+        }
+
+        BlockData(Block block, ImmutableMap immutablemap, Object object) {
+            this(block, immutablemap);
+        }
+    }
+}
-- 
2.5.0
