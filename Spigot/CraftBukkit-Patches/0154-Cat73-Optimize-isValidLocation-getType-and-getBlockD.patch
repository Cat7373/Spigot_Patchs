From f27487b171849254b91e9556fe70ea270d683fae Mon Sep 17 00:00:00 2001
From: Cat73 <cat7373x@gmail.com>
Date: Sun, 17 Jun 2018 14:27:58 +0800
Subject: [PATCH] Cat73 -> Optimize isValidLocation, getType and getBlockData
 for inling
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

热点方法 isValidLocation 优化
这个方法默认实现是无法做内联优化的，以及会判断是否为演示世界，都会浪费一些 CPU 时间
Link: https://github.com/PaperMC/Paper/blob/4f29a0ce0a470ae3ac6be1d69ee7843a78bb9ae1/Spigot-Server-Patches/0086-Optimize-isValidLocation-getType-and-getBlockData-fo.patch

diff --git a/src/main/java/net/minecraft/server/BaseBlockPosition.java b/src/main/java/net/minecraft/server/BaseBlockPosition.java
index d55e180d..679d5504 100644
--- a/src/main/java/net/minecraft/server/BaseBlockPosition.java
+++ b/src/main/java/net/minecraft/server/BaseBlockPosition.java
@@ -10,6 +10,14 @@ public class BaseBlockPosition implements Comparable<BaseBlockPosition> {
     private final int a;
     private final int b;
     private final int c;
+    // Paper start
+    public boolean isValidLocation() {
+        return a >= -30000000 && c >= -30000000 && a < 30000000 && c < 30000000 && b >= 0 && b < 256;
+    }
+    public boolean isInvalidYLocation() {
+        return b < 0 || b >= 256;
+    }
+    // Paper end
 
     public BaseBlockPosition(int i, int j, int k) {
         this.a = i;
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
index 67b476b2..008ed206 100644
--- a/src/main/java/net/minecraft/server/BlockPosition.java
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -339,6 +339,16 @@ public class BlockPosition extends BaseBlockPosition {
         protected int b;
         protected int c;
         protected int d;
+        // Paper start
+        @Override
+        public boolean isValidLocation() {
+            return b >= -30000000 && d >= -30000000 && b < 30000000 && d < 30000000 && c >= 0 && c < 256;
+        }
+        @Override
+        public boolean isInvalidYLocation() {
+            return c < 0 || c >= 256;
+        }
+        // Paper end
 
         public MutableBlockPosition() {
             this(0, 0, 0);
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 6047a3c3..2b0e752f 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -389,11 +389,27 @@ public class Chunk {
         return this.a(i, j, k).c();
     }
 
-    public IBlockData getBlockData(BlockPosition blockposition) {
-        return this.a(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+    // Paper start - Optimize getBlockData to reduce instructions
+    public final IBlockData getBlockData(final BlockPosition pos) {
+        return getBlockData(pos.getX(), pos.getY(), pos.getZ());
+    }
+
+    public final IBlockData getBlockData(final int x, final int y, final int z) {
+        // Method body / logic copied from below
+        final int i = y >> 4;
+        if (y >= 0 && i < this.sections.length && this.sections[i] != null) {
+            // Inlined ChunkSection.getType() and DataPaletteBlock.a(int,int,int)
+            return this.sections[i].blockIds.a((y & 15) << 8 | (z & 15) << 4 | x & 15);
+        }
+        return Blocks.AIR.getBlockData();
     }
 
     public IBlockData a(final int i, final int j, final int k) {
+        return getBlockData(i, j, k);
+    }
+
+    public IBlockData unused(final int i, final int j, final int k) {
+    // Paper end
         if (this.world.N() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             IBlockData iblockdata = null;
 
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
index 3d784d0d..afdc4a77 100644
--- a/src/main/java/net/minecraft/server/ChunkSection.java
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -5,7 +5,7 @@ public class ChunkSection {
     private final int yPos;
     private int nonEmptyBlockCount;
     private int tickingBlockCount;
-    private final DataPaletteBlock blockIds;
+    final DataPaletteBlock blockIds; // Paper - package
     private NibbleArray emittedLight;
     private NibbleArray skyLight;
 
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 7f82acb7..5b0be8ea 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -264,12 +264,12 @@ public abstract class World implements IBlockAccess {
         return this.getType(blockposition1);
     }
 
-    private boolean isValidLocation(BlockPosition blockposition) {
-        return !this.E(blockposition) && blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000;
+    private static boolean isValidLocation(BlockPosition blockposition) { // Paper - unused but incase reflection / future uses
+        return blockposition.isValidLocation(); // Paper
     }
 
-    private boolean E(BlockPosition blockposition) {
-        return blockposition.getY() < 0 || blockposition.getY() >= 256;
+    private static boolean E(BlockPosition blockposition) { // Paper - unused but incase reflection / future uses
+        return blockposition.isInvalidYLocation(); // Paper
     }
 
     public boolean isEmpty(BlockPosition blockposition) {
@@ -365,7 +365,7 @@ public abstract class World implements IBlockAccess {
             return true;
         }
         // CraftBukkit end
-        if (this.E(blockposition)) {
+        if (blockposition.isInvalidYLocation()) { // Paper
             return false;
         } else if (!this.isClientSide && this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             return false;
@@ -766,7 +766,7 @@ public abstract class World implements IBlockAccess {
             blockposition = new BlockPosition(blockposition.getX(), 0, blockposition.getZ());
         }
 
-        if (!this.isValidLocation(blockposition)) {
+        if (!blockposition.isValidLocation()) { // Paper
             return enumskyblock.c;
         } else if (!this.isLoaded(blockposition)) {
             return enumskyblock.c;
@@ -778,7 +778,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void a(EnumSkyBlock enumskyblock, BlockPosition blockposition, int i) {
-        if (this.isValidLocation(blockposition)) {
+        if (blockposition.isValidLocation()) { // Paper
             if (this.isLoaded(blockposition)) {
                 Chunk chunk = this.getChunkAtWorldCoords(blockposition);
 
@@ -802,19 +802,19 @@ public abstract class World implements IBlockAccess {
     // Paper start - reduces need to do isLoaded before getType
     public IBlockData getTypeIfLoaded(BlockPosition blockposition) {
         // CraftBukkit start - tree generation
+        final int x = blockposition.getX();
+        final int y = blockposition.getY();
+        final int z = blockposition.getZ();
         if (captureTreeGeneration) {
-            Iterator<BlockState> it = capturedBlockStates.iterator();
-            while (it.hasNext()) {
-                BlockState previous = it.next();
-                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
-                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
-                }
+            final IBlockData previous = getCapturedBlockType(x, y, z);
+            if (previous != null) {
+                return previous;
             }
         }
         // CraftBukkit end
-        Chunk chunk = this.getChunkIfLoaded(blockposition);
+        Chunk chunk = ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x >> 4, z >> 4);
         if (chunk != null) {
-            return this.isValidLocation(blockposition) ? chunk.getBlockData(blockposition) : Blocks.AIR.getBlockData();
+            return chunk.getBlockData(x, y, z);
         }
         return null;
     }
@@ -822,24 +822,33 @@ public abstract class World implements IBlockAccess {
 
     public IBlockData getType(BlockPosition blockposition) {
         // CraftBukkit start - tree generation
+        // Paper start - optimize getType lookup to reduce instructions - getBlockData already enforces valid Y, move tree out
+        final int x = blockposition.getX();
+        final int y = blockposition.getY();
+        final int z = blockposition.getZ();
         if (captureTreeGeneration) {
-            Iterator<BlockState> it = capturedBlockStates.iterator();
-            while (it.hasNext()) {
-                BlockState previous = it.next();
-                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
-                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
-                }
+            final IBlockData previous = getCapturedBlockType(x, y, z);
+            if (previous != null) {
+                return previous;
             }
         }
         // CraftBukkit end
-        if (this.E(blockposition)) {
-            return Blocks.AIR.getBlockData();
-        } else {
-            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+        return this.chunkProvider.getChunkAt(x >> 4, z >> 4).getBlockData(x, y, z);
+        // Paper end
+    }
 
-            return chunk.getBlockData(blockposition);
+    // Paper start
+    private IBlockData getCapturedBlockType(int x, int y, int z) {
+        Iterator<BlockState> it = capturedBlockStates.iterator();
+        while (it.hasNext()) {
+            BlockState previous = it.next();
+            if (previous.getX() == x && previous.getY() == y && previous.getZ() == z) {
+                return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
+            }
         }
+        return null;
     }
+    // Paper end
 
     public boolean D() {
         return this.L < 4;
@@ -1953,7 +1962,7 @@ public abstract class World implements IBlockAccess {
     public Map<BlockPosition, TileEntity> capturedTileEntities = Maps.newHashMap();
     @Nullable
     public TileEntity getTileEntity(BlockPosition blockposition) {
-        if (this.E(blockposition)) {
+        if (blockposition.isInvalidYLocation()) { // Paper
             return null;
         } else {
             // CraftBukkit start
@@ -1994,7 +2003,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public void setTileEntity(BlockPosition blockposition, @Nullable TileEntity tileentity) {
-        if (!this.E(blockposition)) {
+        if (!blockposition.isInvalidYLocation()) {
             if (tileentity != null && !tileentity.y()) {
             // CraftBukkit start
             if (captureBlockStates) {
@@ -2057,7 +2066,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public boolean d(BlockPosition blockposition, boolean flag) {
-        if (this.E(blockposition)) {
+        if (blockposition.isInvalidYLocation()) { // Paper
             return false;
         } else {
             Chunk chunk = this.chunkProvider.getLoadedChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4);
-- 
2.15.2 (Apple Git-101.1)

