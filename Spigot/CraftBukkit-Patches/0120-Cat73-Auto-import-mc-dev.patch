From 64047ad70e70c88def67dfb84eebb225b874877e Mon Sep 17 00:00:00 2001
From: Cat73 <root@cat73.org>
Date: Sun, 10 Mar 2019 22:07:39 +0800
Subject: [PATCH] Cat73 -> Auto import mc-dev


diff --git a/src/main/java/net/minecraft/server/BaseBlockPosition.java b/src/main/java/net/minecraft/server/BaseBlockPosition.java
new file mode 100644
index 00000000..5843ef65
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BaseBlockPosition.java
@@ -0,0 +1,95 @@
+package net.minecraft.server;
+
+import com.google.common.base.MoreObjects;
+import javax.annotation.concurrent.Immutable;
+
+@Immutable
+public class BaseBlockPosition implements Comparable<BaseBlockPosition> {
+
+    public static final BaseBlockPosition ZERO = new BaseBlockPosition(0, 0, 0);
+    private final int a;
+    private final int b;
+    private final int c;
+
+    public BaseBlockPosition(int i, int j, int k) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+    }
+
+    public BaseBlockPosition(double d0, double d1, double d2) {
+        this(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof BaseBlockPosition)) {
+            return false;
+        } else {
+            BaseBlockPosition baseblockposition = (BaseBlockPosition) object;
+
+            return this.getX() != baseblockposition.getX() ? false : (this.getY() != baseblockposition.getY() ? false : this.getZ() == baseblockposition.getZ());
+        }
+    }
+
+    public int hashCode() {
+        return (this.getY() + this.getZ() * 31) * 31 + this.getX();
+    }
+
+    public int compareTo(BaseBlockPosition baseblockposition) {
+        return this.getY() == baseblockposition.getY() ? (this.getZ() == baseblockposition.getZ() ? this.getX() - baseblockposition.getX() : this.getZ() - baseblockposition.getZ()) : this.getY() - baseblockposition.getY();
+    }
+
+    public int getX() {
+        return this.a;
+    }
+
+    public int getY() {
+        return this.b;
+    }
+
+    public int getZ() {
+        return this.c;
+    }
+
+    public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+        return new BaseBlockPosition(this.getY() * baseblockposition.getZ() - this.getZ() * baseblockposition.getY(), this.getZ() * baseblockposition.getX() - this.getX() * baseblockposition.getZ(), this.getX() * baseblockposition.getY() - this.getY() * baseblockposition.getX());
+    }
+
+    public double h(int i, int j, int k) {
+        double d0 = (double) (this.getX() - i);
+        double d1 = (double) (this.getY() - j);
+        double d2 = (double) (this.getZ() - k);
+
+        return Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+    }
+
+    public double m(BaseBlockPosition baseblockposition) {
+        return this.h(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public double distanceSquared(double d0, double d1, double d2) {
+        double d3 = (double) this.getX() - d0;
+        double d4 = (double) this.getY() - d1;
+        double d5 = (double) this.getZ() - d2;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
+    }
+
+    public double g(double d0, double d1, double d2) {
+        double d3 = (double) this.getX() + 0.5D - d0;
+        double d4 = (double) this.getY() + 0.5D - d1;
+        double d5 = (double) this.getZ() + 0.5D - d2;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
+    }
+
+    public double n(BaseBlockPosition baseblockposition) {
+        return this.distanceSquared((double) baseblockposition.getX(), (double) baseblockposition.getY(), (double) baseblockposition.getZ());
+    }
+
+    public String toString() {
+        return MoreObjects.toStringHelper(this).add("x", this.getX()).add("y", this.getY()).add("z", this.getZ()).toString();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
new file mode 100644
index 00000000..bd2a67cf
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -0,0 +1,377 @@
+package net.minecraft.server;
+
+import com.google.common.collect.AbstractIterator;
+import com.google.common.collect.Lists;
+import java.util.List;
+import javax.annotation.concurrent.Immutable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+@Immutable
+public class BlockPosition extends BaseBlockPosition {
+
+    private static final Logger b = LogManager.getLogger();
+    public static final BlockPosition ZERO = new BlockPosition(0, 0, 0);
+    private static final int c = 1 + MathHelper.e(MathHelper.c(30000000));
+    private static final int d = BlockPosition.c;
+    private static final int f = 64 - BlockPosition.c - BlockPosition.d;
+    private static final int g = 0 + BlockPosition.d;
+    private static final int h = BlockPosition.g + BlockPosition.f;
+    private static final long i = (1L << BlockPosition.c) - 1L;
+    private static final long j = (1L << BlockPosition.f) - 1L;
+    private static final long k = (1L << BlockPosition.d) - 1L;
+
+    public BlockPosition(int i, int j, int k) {
+        super(i, j, k);
+    }
+
+    public BlockPosition(double d0, double d1, double d2) {
+        super(d0, d1, d2);
+    }
+
+    public BlockPosition(Entity entity) {
+        this(entity.locX, entity.locY, entity.locZ);
+    }
+
+    public BlockPosition(Vec3D vec3d) {
+        this(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public BlockPosition(BaseBlockPosition baseblockposition) {
+        this(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public BlockPosition a(double d0, double d1, double d2) {
+        return d0 == 0.0D && d1 == 0.0D && d2 == 0.0D ? this : new BlockPosition((double) this.getX() + d0, (double) this.getY() + d1, (double) this.getZ() + d2);
+    }
+
+    public BlockPosition a(int i, int j, int k) {
+        return i == 0 && j == 0 && k == 0 ? this : new BlockPosition(this.getX() + i, this.getY() + j, this.getZ() + k);
+    }
+
+    public BlockPosition a(BaseBlockPosition baseblockposition) {
+        return this.a(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public BlockPosition b(BaseBlockPosition baseblockposition) {
+        return this.a(-baseblockposition.getX(), -baseblockposition.getY(), -baseblockposition.getZ());
+    }
+
+    public BlockPosition up() {
+        return this.up(1);
+    }
+
+    public BlockPosition up(int i) {
+        return this.shift(EnumDirection.UP, i);
+    }
+
+    public BlockPosition down() {
+        return this.down(1);
+    }
+
+    public BlockPosition down(int i) {
+        return this.shift(EnumDirection.DOWN, i);
+    }
+
+    public BlockPosition north() {
+        return this.north(1);
+    }
+
+    public BlockPosition north(int i) {
+        return this.shift(EnumDirection.NORTH, i);
+    }
+
+    public BlockPosition south() {
+        return this.south(1);
+    }
+
+    public BlockPosition south(int i) {
+        return this.shift(EnumDirection.SOUTH, i);
+    }
+
+    public BlockPosition west() {
+        return this.west(1);
+    }
+
+    public BlockPosition west(int i) {
+        return this.shift(EnumDirection.WEST, i);
+    }
+
+    public BlockPosition east() {
+        return this.east(1);
+    }
+
+    public BlockPosition east(int i) {
+        return this.shift(EnumDirection.EAST, i);
+    }
+
+    public BlockPosition shift(EnumDirection enumdirection) {
+        return this.shift(enumdirection, 1);
+    }
+
+    public BlockPosition shift(EnumDirection enumdirection, int i) {
+        return i == 0 ? this : new BlockPosition(this.getX() + enumdirection.getAdjacentX() * i, this.getY() + enumdirection.getAdjacentY() * i, this.getZ() + enumdirection.getAdjacentZ() * i);
+    }
+
+    public BlockPosition a(EnumBlockRotation enumblockrotation) {
+        switch (enumblockrotation) {
+        case NONE:
+        default:
+            return this;
+        case CLOCKWISE_90:
+            return new BlockPosition(-this.getZ(), this.getY(), this.getX());
+        case CLOCKWISE_180:
+            return new BlockPosition(-this.getX(), this.getY(), -this.getZ());
+        case COUNTERCLOCKWISE_90:
+            return new BlockPosition(this.getZ(), this.getY(), -this.getX());
+        }
+    }
+
+    public BlockPosition d(BaseBlockPosition baseblockposition) {
+        return new BlockPosition(this.getY() * baseblockposition.getZ() - this.getZ() * baseblockposition.getY(), this.getZ() * baseblockposition.getX() - this.getX() * baseblockposition.getZ(), this.getX() * baseblockposition.getY() - this.getY() * baseblockposition.getX());
+    }
+
+    public long asLong() {
+        return ((long) this.getX() & BlockPosition.i) << BlockPosition.h | ((long) this.getY() & BlockPosition.j) << BlockPosition.g | ((long) this.getZ() & BlockPosition.k) << 0;
+    }
+
+    public static BlockPosition fromLong(long i) {
+        int j = (int) (i << 64 - BlockPosition.h - BlockPosition.c >> 64 - BlockPosition.c);
+        int k = (int) (i << 64 - BlockPosition.g - BlockPosition.f >> 64 - BlockPosition.f);
+        int l = (int) (i << 64 - BlockPosition.d >> 64 - BlockPosition.d);
+
+        return new BlockPosition(j, k, l);
+    }
+
+    public static Iterable<BlockPosition> a(BlockPosition blockposition, BlockPosition blockposition1) {
+        return a(Math.min(blockposition.getX(), blockposition1.getX()), Math.min(blockposition.getY(), blockposition1.getY()), Math.min(blockposition.getZ(), blockposition1.getZ()), Math.max(blockposition.getX(), blockposition1.getX()), Math.max(blockposition.getY(), blockposition1.getY()), Math.max(blockposition.getZ(), blockposition1.getZ()));
+    }
+
+    public static Iterable<BlockPosition> a(int i, int j, int k, int l, int i1, int j1) {
+        return () -> {
+            return new AbstractIterator<BlockPosition>() {
+                private boolean g = true;
+                private int h;
+                private int i;
+                private int j;
+
+                protected BlockPosition computeNext() {
+                    if (this.g) {
+                        this.g = false;
+                        this.h = i;
+                        this.i = j;
+                        this.j = k;
+                        return new BlockPosition(i, j, k);
+                    } else if (this.h == l && this.i == i1 && this.j == j1) {
+                        return (BlockPosition) this.endOfData();
+                    } else {
+                        if (this.h < l) {
+                            ++this.h;
+                        } else if (this.i < i1) {
+                            this.h = i;
+                            ++this.i;
+                        } else if (this.j < j1) {
+                            this.h = i;
+                            this.i = j;
+                            ++this.j;
+                        }
+
+                        return new BlockPosition(this.h, this.i, this.j);
+                    }
+                }
+            };
+        };
+    }
+
+    public BlockPosition h() {
+        return this;
+    }
+
+    public static Iterable<BlockPosition.MutableBlockPosition> b(BlockPosition blockposition, BlockPosition blockposition1) {
+        return b(Math.min(blockposition.getX(), blockposition1.getX()), Math.min(blockposition.getY(), blockposition1.getY()), Math.min(blockposition.getZ(), blockposition1.getZ()), Math.max(blockposition.getX(), blockposition1.getX()), Math.max(blockposition.getY(), blockposition1.getY()), Math.max(blockposition.getZ(), blockposition1.getZ()));
+    }
+
+    public static Iterable<BlockPosition.MutableBlockPosition> b(int i, int j, int k, int l, int i1, int j1) {
+        return () -> {
+            return new AbstractIterator<BlockPosition.MutableBlockPosition>() {
+                private BlockPosition.MutableBlockPosition g;
+
+                protected BlockPosition.MutableBlockPosition computeNext() {
+                    if (this.g == null) {
+                        this.g = new BlockPosition.MutableBlockPosition(i, j, k);
+                        return this.g;
+                    } else if (this.g.b == l && this.g.c == i1 && this.g.d == j1) {
+                        return (BlockPosition.MutableBlockPosition) this.endOfData();
+                    } else {
+                        if (this.g.b < l) {
+                            ++this.g.b;
+                        } else if (this.g.c < i1) {
+                            ++this.g.c;
+                        } else if (this.g.d < j1) {
+                            ++this.g.d;
+                        }
+
+                        return this.g;
+                    }
+                }
+            };
+        };
+    }
+
+    public static final class b extends BlockPosition.MutableBlockPosition implements AutoCloseable {
+
+        private boolean f;
+        private static final List<BlockPosition.b> g = Lists.newArrayList();
+
+        private b(int i, int j, int k) {
+            super(i, j, k);
+        }
+
+        public static BlockPosition.b r() {
+            return e(0, 0, 0);
+        }
+
+        public static BlockPosition.b b(Entity entity) {
+            return d(entity.locX, entity.locY, entity.locZ);
+        }
+
+        public static BlockPosition.b d(double d0, double d1, double d2) {
+            return e(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+        }
+
+        public static BlockPosition.b e(int i, int j, int k) {
+            synchronized (BlockPosition.b.g) {
+                if (!BlockPosition.b.g.isEmpty()) {
+                    BlockPosition.b blockposition_b = (BlockPosition.b) BlockPosition.b.g.remove(BlockPosition.b.g.size() - 1);
+
+                    if (blockposition_b != null && blockposition_b.f) {
+                        blockposition_b.f = false;
+                        blockposition_b.c(i, j, k);
+                        return blockposition_b;
+                    }
+                }
+            }
+
+            return new BlockPosition.b(i, j, k);
+        }
+
+        public BlockPosition.b c(int i, int j, int k) {
+            return (BlockPosition.b) super.c(i, j, k);
+        }
+
+        public BlockPosition.b c(double d0, double d1, double d2) {
+            return (BlockPosition.b) super.c(d0, d1, d2);
+        }
+
+        public BlockPosition.b g(BaseBlockPosition baseblockposition) {
+            return (BlockPosition.b) super.g(baseblockposition);
+        }
+
+        public BlockPosition.b c(EnumDirection enumdirection) {
+            return (BlockPosition.b) super.c(enumdirection);
+        }
+
+        public BlockPosition.b c(EnumDirection enumdirection, int i) {
+            return (BlockPosition.b) super.c(enumdirection, i);
+        }
+
+        public BlockPosition.b d(int i, int j, int k) {
+            return (BlockPosition.b) super.d(i, j, k);
+        }
+
+        public void close() {
+            synchronized (BlockPosition.b.g) {
+                if (BlockPosition.b.g.size() < 100) {
+                    BlockPosition.b.g.add(this);
+                }
+
+                this.f = true;
+            }
+        }
+    }
+
+    public static class MutableBlockPosition extends BlockPosition {
+
+        protected int b;
+        protected int c;
+        protected int d;
+
+        public MutableBlockPosition() {
+            this(0, 0, 0);
+        }
+
+        public MutableBlockPosition(BlockPosition blockposition) {
+            this(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+        }
+
+        public MutableBlockPosition(int i, int j, int k) {
+            super(0, 0, 0);
+            this.b = i;
+            this.c = j;
+            this.d = k;
+        }
+
+        public BlockPosition a(double d0, double d1, double d2) {
+            return super.a(d0, d1, d2).h();
+        }
+
+        public BlockPosition a(int i, int j, int k) {
+            return super.a(i, j, k).h();
+        }
+
+        public BlockPosition shift(EnumDirection enumdirection, int i) {
+            return super.shift(enumdirection, i).h();
+        }
+
+        public BlockPosition a(EnumBlockRotation enumblockrotation) {
+            return super.a(enumblockrotation).h();
+        }
+
+        public int getX() {
+            return this.b;
+        }
+
+        public int getY() {
+            return this.c;
+        }
+
+        public int getZ() {
+            return this.d;
+        }
+
+        public BlockPosition.MutableBlockPosition c(int i, int j, int k) {
+            this.b = i;
+            this.c = j;
+            this.d = k;
+            return this;
+        }
+
+        public BlockPosition.MutableBlockPosition c(double d0, double d1, double d2) {
+            return this.c(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+        }
+
+        public BlockPosition.MutableBlockPosition g(BaseBlockPosition baseblockposition) {
+            return this.c(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection) {
+            return this.c(enumdirection, 1);
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection, int i) {
+            return this.c(this.b + enumdirection.getAdjacentX() * i, this.c + enumdirection.getAdjacentY() * i, this.d + enumdirection.getAdjacentZ() * i);
+        }
+
+        public BlockPosition.MutableBlockPosition d(int i, int j, int k) {
+            return this.c(this.b + i, this.c + j, this.d + k);
+        }
+
+        public void p(int i) {
+            this.c = i;
+        }
+
+        public BlockPosition h() {
+            return new BlockPosition(this);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkCache.java b/src/main/java/net/minecraft/server/ChunkCache.java
new file mode 100644
index 00000000..49533ac3
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkCache.java
@@ -0,0 +1,220 @@
+package net.minecraft.server;
+
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+
+public class ChunkCache implements IIBlockAccess {
+
+    protected int a;
+    protected int b;
+    protected Chunk[][] c;
+    protected boolean d;
+    protected World e;
+
+    public ChunkCache(World world, BlockPosition blockposition, BlockPosition blockposition1, int i) {
+        this.e = world;
+        this.a = blockposition.getX() - i >> 4;
+        this.b = blockposition.getZ() - i >> 4;
+        int j = blockposition1.getX() + i >> 4;
+        int k = blockposition1.getZ() + i >> 4;
+
+        this.c = new Chunk[j - this.a + 1][k - this.b + 1];
+        this.d = true;
+
+        int l;
+        int i1;
+
+        for (l = this.a; l <= j; ++l) {
+            for (i1 = this.b; i1 <= k; ++i1) {
+                this.c[l - this.a][i1 - this.b] = world.getChunkAt(l, i1);
+            }
+        }
+
+        for (l = blockposition.getX() >> 4; l <= blockposition1.getX() >> 4; ++l) {
+            for (i1 = blockposition.getZ() >> 4; i1 <= blockposition1.getZ() >> 4; ++i1) {
+                Chunk chunk = this.c[l - this.a][i1 - this.b];
+
+                if (chunk != null && !chunk.b(blockposition.getY(), blockposition1.getY())) {
+                    this.d = false;
+                }
+            }
+        }
+
+    }
+
+    @Nullable
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        return this.a(blockposition, Chunk.EnumTileEntityState.IMMEDIATE);
+    }
+
+    @Nullable
+    public TileEntity a(BlockPosition blockposition, Chunk.EnumTileEntityState chunk_enumtileentitystate) {
+        int i = (blockposition.getX() >> 4) - this.a;
+        int j = (blockposition.getZ() >> 4) - this.b;
+
+        return this.c[i][j].a(blockposition, chunk_enumtileentitystate);
+    }
+
+    public float A(BlockPosition blockposition) {
+        return this.e.worldProvider.i()[this.getLightLevel(blockposition)];
+    }
+
+    public int d(BlockPosition blockposition, int i) {
+        if (this.getType(blockposition).c(this, blockposition)) {
+            int j = 0;
+            EnumDirection[] aenumdirection = EnumDirection.values();
+            int k = aenumdirection.length;
+
+            for (int l = 0; l < k; ++l) {
+                EnumDirection enumdirection = aenumdirection[l];
+                int i1 = this.getLightLevel(blockposition.shift(enumdirection), i);
+
+                if (i1 > j) {
+                    j = i1;
+                }
+
+                if (j >= 15) {
+                    return j;
+                }
+            }
+
+            return j;
+        } else {
+            return this.getLightLevel(blockposition, i);
+        }
+    }
+
+    public WorldProvider o() {
+        return this.e.o();
+    }
+
+    public int getLightLevel(BlockPosition blockposition, int i) {
+        if (blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() <= 30000000) {
+            if (blockposition.getY() < 0) {
+                return 0;
+            } else {
+                int j;
+
+                if (blockposition.getY() >= 256) {
+                    j = 15 - i;
+                    if (j < 0) {
+                        j = 0;
+                    }
+
+                    return j;
+                } else {
+                    j = (blockposition.getX() >> 4) - this.a;
+                    int k = (blockposition.getZ() >> 4) - this.b;
+
+                    return this.c[j][k].a(blockposition, i);
+                }
+            }
+        } else {
+            return 15;
+        }
+    }
+
+    public boolean isChunkLoaded(int i, int j, boolean flag) {
+        return this.a(i, j);
+    }
+
+    public boolean e(BlockPosition blockposition) {
+        return false;
+    }
+
+    public boolean a(int i, int j) {
+        int k = i - this.a;
+        int l = j - this.b;
+
+        return k >= 0 && k < this.c.length && l >= 0 && l < this.c[k].length;
+    }
+
+    public int a(HeightMap.Type heightmap_type, int i, int j) {
+        throw new RuntimeException("NOT IMPLEMENTED!");
+    }
+
+    public WorldBorder getWorldBorder() {
+        return this.e.getWorldBorder();
+    }
+
+    public boolean a(@Nullable Entity entity, VoxelShape voxelshape) {
+        throw new RuntimeException("This method should never be called here. No entity logic inside Region");
+    }
+
+    @Nullable
+    public EntityHuman a(double d0, double d1, double d2, double d3, Predicate<Entity> predicate) {
+        throw new RuntimeException("This method should never be called here. No entity logic inside Region");
+    }
+
+    public IBlockData getType(BlockPosition blockposition) {
+        if (blockposition.getY() >= 0 && blockposition.getY() < 256) {
+            int i = (blockposition.getX() >> 4) - this.a;
+            int j = (blockposition.getZ() >> 4) - this.b;
+
+            if (i >= 0 && i < this.c.length && j >= 0 && j < this.c[i].length) {
+                Chunk chunk = this.c[i][j];
+
+                if (chunk != null) {
+                    return chunk.getType(blockposition);
+                }
+            }
+        }
+
+        return Blocks.AIR.getBlockData();
+    }
+
+    public Fluid getFluid(BlockPosition blockposition) {
+        if (blockposition.getY() >= 0 && blockposition.getY() < 256) {
+            int i = (blockposition.getX() >> 4) - this.a;
+            int j = (blockposition.getZ() >> 4) - this.b;
+
+            if (i >= 0 && i < this.c.length && j >= 0 && j < this.c[i].length) {
+                Chunk chunk = this.c[i][j];
+
+                if (chunk != null) {
+                    return chunk.getFluid(blockposition);
+                }
+            }
+        }
+
+        return FluidTypes.EMPTY.i();
+    }
+
+    public int c() {
+        return 0;
+    }
+
+    public BiomeBase getBiome(BlockPosition blockposition) {
+        int i = (blockposition.getX() >> 4) - this.a;
+        int j = (blockposition.getZ() >> 4) - this.b;
+
+        return this.c[i][j].getBiome(blockposition);
+    }
+
+    public boolean isEmpty(BlockPosition blockposition) {
+        return this.getType(blockposition).isAir();
+    }
+
+    public int getBrightness(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
+        if (blockposition.getY() >= 0 && blockposition.getY() < 256) {
+            int i = (blockposition.getX() >> 4) - this.a;
+            int j = (blockposition.getZ() >> 4) - this.b;
+
+            return this.c[i][j].getBrightness(enumskyblock, blockposition);
+        } else {
+            return enumskyblock.c;
+        }
+    }
+
+    public int a(BlockPosition blockposition, EnumDirection enumdirection) {
+        return this.getType(blockposition).b((IBlockAccess) this, blockposition, enumdirection);
+    }
+
+    public boolean e() {
+        throw new RuntimeException("Not yet implemented");
+    }
+
+    public int getSeaLevel() {
+        throw new RuntimeException("Not yet implemented");
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
new file mode 100644
index 00000000..d24ec3d5
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -0,0 +1,74 @@
+package net.minecraft.server;
+
+import org.apache.commons.lang3.Validate;
+
+public class DataBits {
+
+    private final long[] a;
+    private final int b;
+    private final long c;
+    private final int d;
+
+    public DataBits(int i, int j) {
+        this(i, j, new long[MathHelper.c(j * i, 64) / 64]);
+    }
+
+    public DataBits(int i, int j, long[] along) {
+        Validate.inclusiveBetween(1L, 32L, (long) i);
+        this.d = j;
+        this.b = i;
+        this.a = along;
+        this.c = (1L << i) - 1L;
+        int k = MathHelper.c(j * i, 64) / 64;
+
+        if (along.length != k) {
+            throw new RuntimeException("Invalid length given for storage, got: " + along.length + " but expected: " + k);
+        }
+    }
+
+    public void a(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.c, (long) j);
+        int k = i * this.b;
+        int l = k / 64;
+        int i1 = ((i + 1) * this.b - 1) / 64;
+        int j1 = k % 64;
+
+        this.a[l] = this.a[l] & ~(this.c << j1) | ((long) j & this.c) << j1;
+        if (l != i1) {
+            int k1 = 64 - j1;
+            int l1 = this.b - k1;
+
+            this.a[i1] = this.a[i1] >>> l1 << l1 | ((long) j & this.c) >> k1;
+        }
+
+    }
+
+    public int a(int i) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        int j = i * this.b;
+        int k = j / 64;
+        int l = ((i + 1) * this.b - 1) / 64;
+        int i1 = j % 64;
+
+        if (k == l) {
+            return (int) (this.a[k] >>> i1 & this.c);
+        } else {
+            int j1 = 64 - i1;
+
+            return (int) ((this.a[k] >>> i1 | this.a[l] << j1) & this.c);
+        }
+    }
+
+    public long[] a() {
+        return this.a;
+    }
+
+    public int b() {
+        return this.d;
+    }
+
+    public int c() {
+        return this.b;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NavigationAbstract.java b/src/main/java/net/minecraft/server/NavigationAbstract.java
new file mode 100644
index 00000000..2d788ef6
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NavigationAbstract.java
@@ -0,0 +1,310 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public abstract class NavigationAbstract {
+
+    protected EntityInsentient a;
+    protected World b;
+    @Nullable
+    protected PathEntity c;
+    protected double d;
+    private final AttributeInstance p;
+    protected int e;
+    protected int f;
+    protected Vec3D g;
+    protected Vec3D h;
+    protected long i;
+    protected long j;
+    protected double k;
+    protected float l;
+    protected boolean m;
+    protected long n;
+    protected PathfinderAbstract o;
+    private BlockPosition q;
+    private Pathfinder r;
+
+    public NavigationAbstract(EntityInsentient entityinsentient, World world) {
+        this.g = Vec3D.a;
+        this.h = Vec3D.a;
+        this.l = 0.5F;
+        this.a = entityinsentient;
+        this.b = world;
+        this.p = entityinsentient.getAttributeInstance(GenericAttributes.FOLLOW_RANGE);
+        this.r = this.a();
+    }
+
+    public BlockPosition i() {
+        return this.q;
+    }
+
+    protected abstract Pathfinder a();
+
+    public void a(double d0) {
+        this.d = d0;
+    }
+
+    public float j() {
+        return (float) this.p.getValue();
+    }
+
+    public boolean k() {
+        return this.m;
+    }
+
+    public void l() {
+        if (this.b.getTime() - this.n > 20L) {
+            if (this.q != null) {
+                this.c = null;
+                this.c = this.b(this.q);
+                this.n = this.b.getTime();
+                this.m = false;
+            }
+        } else {
+            this.m = true;
+        }
+
+    }
+
+    @Nullable
+    public final PathEntity a(double d0, double d1, double d2) {
+        return this.b(new BlockPosition(d0, d1, d2));
+    }
+
+    @Nullable
+    public PathEntity b(BlockPosition blockposition) {
+        if (!this.b()) {
+            return null;
+        } else if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+            return this.c;
+        } else {
+            this.q = blockposition;
+            float f = this.j();
+
+            this.b.methodProfiler.enter("pathfind");
+            BlockPosition blockposition1 = new BlockPosition(this.a);
+            int i = (int) (f + 8.0F);
+            ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+            PathEntity pathentity = this.r.a(chunkcache, this.a, this.q, f);
+
+            this.b.methodProfiler.exit();
+            return pathentity;
+        }
+    }
+
+    @Nullable
+    public PathEntity a(Entity entity) {
+        if (!this.b()) {
+            return null;
+        } else {
+            BlockPosition blockposition = new BlockPosition(entity);
+
+            if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+                return this.c;
+            } else {
+                this.q = blockposition;
+                float f = this.j();
+
+                this.b.methodProfiler.enter("pathfind");
+                BlockPosition blockposition1 = (new BlockPosition(this.a)).up();
+                int i = (int) (f + 16.0F);
+                ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+                PathEntity pathentity = this.r.a(chunkcache, this.a, entity, f);
+
+                this.b.methodProfiler.exit();
+                return pathentity;
+            }
+        }
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3) {
+        return this.a(this.a(d0, d1, d2), d3);
+    }
+
+    public boolean a(Entity entity, double d0) {
+        PathEntity pathentity = this.a(entity);
+
+        return pathentity != null && this.a(pathentity, d0);
+    }
+
+    public boolean a(@Nullable PathEntity pathentity, double d0) {
+        if (pathentity == null) {
+            this.c = null;
+            return false;
+        } else {
+            if (!pathentity.a(this.c)) {
+                this.c = pathentity;
+            }
+
+            this.E_();
+            if (this.c.d() <= 0) {
+                return false;
+            } else {
+                this.d = d0;
+                Vec3D vec3d = this.c();
+
+                this.f = this.e;
+                this.g = vec3d;
+                return true;
+            }
+        }
+    }
+
+    @Nullable
+    public PathEntity m() {
+        return this.c;
+    }
+
+    public void d() {
+        ++this.e;
+        if (this.m) {
+            this.l();
+        }
+
+        if (!this.p()) {
+            Vec3D vec3d;
+
+            if (this.b()) {
+                this.o();
+            } else if (this.c != null && this.c.e() < this.c.d()) {
+                vec3d = this.c();
+                Vec3D vec3d1 = this.c.a(this.a, this.c.e());
+
+                if (vec3d.y > vec3d1.y && !this.a.onGround && MathHelper.floor(vec3d.x) == MathHelper.floor(vec3d1.x) && MathHelper.floor(vec3d.z) == MathHelper.floor(vec3d1.z)) {
+                    this.c.c(this.c.e() + 1);
+                }
+            }
+
+            this.n();
+            if (!this.p()) {
+                vec3d = this.c.a((Entity) this.a);
+                BlockPosition blockposition = new BlockPosition(vec3d);
+
+                this.a.getControllerMove().a(vec3d.x, this.b.getType(blockposition.down()).isAir() ? vec3d.y : PathfinderNormal.a((IBlockAccess) this.b, blockposition), vec3d.z, this.d);
+            }
+        }
+    }
+
+    protected void n() {}
+
+    protected void o() {
+        Vec3D vec3d = this.c();
+        int i = this.c.d();
+
+        for (int j = this.c.e(); j < this.c.d(); ++j) {
+            if ((double) this.c.a(j).b != Math.floor(vec3d.y)) {
+                i = j;
+                break;
+            }
+        }
+
+        this.l = this.a.width > 0.75F ? this.a.width / 2.0F : 0.75F - this.a.width / 2.0F;
+        Vec3D vec3d1 = this.c.f();
+
+        if (MathHelper.e((float) (this.a.locX - (vec3d1.x + 0.5D))) < this.l && MathHelper.e((float) (this.a.locZ - (vec3d1.z + 0.5D))) < this.l && Math.abs(this.a.locY - vec3d1.y) < 1.0D) {
+            this.c.c(this.c.e() + 1);
+        }
+
+        int k = MathHelper.f(this.a.width);
+        int l = MathHelper.f(this.a.length);
+        int i1 = k;
+
+        for (int j1 = i - 1; j1 >= this.c.e(); --j1) {
+            if (this.a(vec3d, this.c.a(this.a, j1), k, l, i1)) {
+                this.c.c(j1);
+                break;
+            }
+        }
+
+        this.a(vec3d);
+    }
+
+    protected void a(Vec3D vec3d) {
+        if (this.e - this.f > 100) {
+            if (vec3d.distanceSquared(this.g) < 2.25D) {
+                this.q();
+            }
+
+            this.f = this.e;
+            this.g = vec3d;
+        }
+
+        if (this.c != null && !this.c.b()) {
+            Vec3D vec3d1 = this.c.f();
+
+            if (vec3d1.equals(this.h)) {
+                this.i += SystemUtils.getMonotonicMillis() - this.j;
+            } else {
+                this.h = vec3d1;
+                double d0 = vec3d.f(this.h);
+
+                this.k = this.a.cK() > 0.0F ? d0 / (double) this.a.cK() * 1000.0D : 0.0D;
+            }
+
+            if (this.k > 0.0D && (double) this.i > this.k * 3.0D) {
+                this.h = Vec3D.a;
+                this.i = 0L;
+                this.k = 0.0D;
+                this.q();
+            }
+
+            this.j = SystemUtils.getMonotonicMillis();
+        }
+
+    }
+
+    public boolean p() {
+        return this.c == null || this.c.b();
+    }
+
+    public void q() {
+        this.c = null;
+    }
+
+    protected abstract Vec3D c();
+
+    protected abstract boolean b();
+
+    protected boolean r() {
+        return this.a.aq() || this.a.ax();
+    }
+
+    protected void E_() {
+        if (this.c != null) {
+            for (int i = 0; i < this.c.d(); ++i) {
+                PathPoint pathpoint = this.c.a(i);
+                PathPoint pathpoint1 = i + 1 < this.c.d() ? this.c.a(i + 1) : null;
+                IBlockData iblockdata = this.b.getType(new BlockPosition(pathpoint.a, pathpoint.b, pathpoint.c));
+                Block block = iblockdata.getBlock();
+
+                if (block == Blocks.CAULDRON) {
+                    this.c.a(i, pathpoint.a(pathpoint.a, pathpoint.b + 1, pathpoint.c));
+                    if (pathpoint1 != null && pathpoint.b >= pathpoint1.b) {
+                        this.c.a(i + 1, pathpoint1.a(pathpoint1.a, pathpoint.b + 1, pathpoint1.c));
+                    }
+                }
+            }
+
+        }
+    }
+
+    protected abstract boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k);
+
+    public boolean a(BlockPosition blockposition) {
+        BlockPosition blockposition1 = blockposition.down();
+
+        return this.b.getType(blockposition1).f(this.b, blockposition1);
+    }
+
+    public PathfinderAbstract s() {
+        return this.o;
+    }
+
+    public void d(boolean flag) {
+        this.o.c(flag);
+    }
+
+    public boolean t() {
+        return this.o.e();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PersistentVillage.java b/src/main/java/net/minecraft/server/PersistentVillage.java
new file mode 100644
index 00000000..98c6bbc1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PersistentVillage.java
@@ -0,0 +1,268 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+
+public class PersistentVillage extends PersistentBase {
+
+    private World world;
+    private final List<BlockPosition> b = Lists.newArrayList();
+    private final List<VillageDoor> c = Lists.newArrayList();
+    private final List<Village> villages = Lists.newArrayList();
+    private int time;
+
+    public PersistentVillage(String s) {
+        super(s);
+    }
+
+    public PersistentVillage(World world) {
+        super(a(world.worldProvider));
+        this.world = world;
+        this.c();
+    }
+
+    public void a(World world) {
+        this.world = world;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(world);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition) {
+        if (this.b.size() <= 64) {
+            if (!this.d(blockposition)) {
+                this.b.add(blockposition);
+            }
+
+        }
+    }
+
+    public void tick() {
+        ++this.time;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(this.time);
+        }
+
+        this.f();
+        this.g();
+        this.h();
+        if (this.time % 400 == 0) {
+            this.c();
+        }
+
+    }
+
+    private void f() {
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            if (village.g()) {
+                iterator.remove();
+                this.c();
+            }
+        }
+
+    }
+
+    public List<Village> getVillages() {
+        return this.villages;
+    }
+
+    public Village getClosestVillage(BlockPosition blockposition, int i) {
+        Village village = null;
+        double d0 = 3.4028234663852886E38D;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village1 = (Village) iterator.next();
+            double d1 = village1.a().n(blockposition);
+
+            if (d1 < d0) {
+                float f = (float) (i + village1.b());
+
+                if (d1 <= (double) (f * f)) {
+                    village = village1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return village;
+    }
+
+    private void g() {
+        if (!this.b.isEmpty()) {
+            this.b((BlockPosition) this.b.remove(0));
+        }
+    }
+
+    private void h() {
+        for (int i = 0; i < this.c.size(); ++i) {
+            VillageDoor villagedoor = (VillageDoor) this.c.get(i);
+            Village village = this.getClosestVillage(villagedoor.d(), 32);
+
+            if (village == null) {
+                village = new Village(this.world);
+                this.villages.add(village);
+                this.c();
+            }
+
+            village.a(villagedoor);
+        }
+
+        this.c.clear();
+    }
+
+    private void b(BlockPosition blockposition) {
+        boolean flag = true;
+        boolean flag1 = true;
+        boolean flag2 = true;
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+        for (int i = -16; i < 16; ++i) {
+            for (int j = -4; j < 4; ++j) {
+                for (int k = -16; k < 16; ++k) {
+                    blockposition_mutableblockposition.g(blockposition).d(i, j, k);
+                    IBlockData iblockdata = this.world.getType(blockposition_mutableblockposition);
+
+                    if (this.a(iblockdata)) {
+                        VillageDoor villagedoor = this.c(blockposition_mutableblockposition);
+
+                        if (villagedoor == null) {
+                            this.a(iblockdata, blockposition_mutableblockposition);
+                        } else {
+                            villagedoor.a(this.time);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    @Nullable
+    private VillageDoor c(BlockPosition blockposition) {
+        Iterator iterator = this.c.iterator();
+
+        VillageDoor villagedoor;
+
+        do {
+            if (!iterator.hasNext()) {
+                iterator = this.villages.iterator();
+
+                VillageDoor villagedoor1;
+
+                do {
+                    if (!iterator.hasNext()) {
+                        return null;
+                    }
+
+                    Village village = (Village) iterator.next();
+
+                    villagedoor1 = village.e(blockposition);
+                } while (villagedoor1 == null);
+
+                return villagedoor1;
+            }
+
+            villagedoor = (VillageDoor) iterator.next();
+        } while (villagedoor.d().getX() != blockposition.getX() || villagedoor.d().getZ() != blockposition.getZ() || Math.abs(villagedoor.d().getY() - blockposition.getY()) > 1);
+
+        return villagedoor;
+    }
+
+    private void a(IBlockData iblockdata, BlockPosition blockposition) {
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockDoor.FACING);
+        EnumDirection enumdirection1 = enumdirection.opposite();
+        int i = this.a(blockposition, enumdirection, 5);
+        int j = this.a(blockposition, enumdirection1, i + 1);
+
+        if (i != j) {
+            this.c.add(new VillageDoor(blockposition, i < j ? enumdirection : enumdirection1, this.time));
+        }
+
+    }
+
+    private int a(BlockPosition blockposition, EnumDirection enumdirection, int i) {
+        int j = 0;
+
+        for (int k = 1; k <= 5; ++k) {
+            if (this.world.e(blockposition.shift(enumdirection, k))) {
+                ++j;
+                if (j >= i) {
+                    return j;
+                }
+            }
+        }
+
+        return j;
+    }
+
+    private boolean d(BlockPosition blockposition) {
+        Iterator iterator = this.b.iterator();
+
+        BlockPosition blockposition1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            blockposition1 = (BlockPosition) iterator.next();
+        } while (!blockposition1.equals(blockposition));
+
+        return true;
+    }
+
+    private boolean a(IBlockData iblockdata) {
+        return iblockdata.getBlock() instanceof BlockDoor && iblockdata.getMaterial() == Material.WOOD;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        this.time = nbttagcompound.getInt("Tick");
+        NBTTagList nbttaglist = nbttagcompound.getList("Villages", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.getCompound(i);
+            Village village = new Village();
+
+            village.a(nbttagcompound1);
+            this.villages.add(village);
+        }
+
+    }
+
+    public NBTTagCompound b(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("Tick", this.time);
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            village.b(nbttagcompound1);
+            nbttaglist.add((NBTBase) nbttagcompound1);
+        }
+
+        nbttagcompound.set("Villages", nbttaglist);
+        return nbttagcompound;
+    }
+
+    public static String a(WorldProvider worldprovider) {
+        return "villages" + worldprovider.getDimensionManager().d();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityEnderChest.java b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
new file mode 100644
index 00000000..ee19595d
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
@@ -0,0 +1,89 @@
+package net.minecraft.server;
+
+public class TileEntityEnderChest extends TileEntity implements ITickable {
+
+    public float a;
+    public float e;
+    public int f;
+    private int g;
+
+    public TileEntityEnderChest() {
+        super(TileEntityTypes.ENDER_CHEST);
+    }
+
+    public void tick() {
+        if (++this.g % 20 * 4 == 0) {
+            this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.f);
+        }
+
+        this.e = this.a;
+        int i = this.position.getX();
+        int j = this.position.getY();
+        int k = this.position.getZ();
+        float f = 0.1F;
+        double d0;
+
+        if (this.f > 0 && this.a == 0.0F) {
+            double d1 = (double) i + 0.5D;
+
+            d0 = (double) k + 0.5D;
+            this.world.a((EntityHuman) null, d1, (double) j + 0.5D, d0, SoundEffects.BLOCK_ENDER_CHEST_OPEN, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+        }
+
+        if (this.f == 0 && this.a > 0.0F || this.f > 0 && this.a < 1.0F) {
+            float f1 = this.a;
+
+            if (this.f > 0) {
+                this.a += 0.1F;
+            } else {
+                this.a -= 0.1F;
+            }
+
+            if (this.a > 1.0F) {
+                this.a = 1.0F;
+            }
+
+            float f2 = 0.5F;
+
+            if (this.a < 0.5F && f1 >= 0.5F) {
+                d0 = (double) i + 0.5D;
+                double d2 = (double) k + 0.5D;
+
+                this.world.a((EntityHuman) null, d0, (double) j + 0.5D, d2, SoundEffects.BLOCK_ENDER_CHEST_CLOSE, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+            }
+
+            if (this.a < 0.0F) {
+                this.a = 0.0F;
+            }
+        }
+
+    }
+
+    public boolean c(int i, int j) {
+        if (i == 1) {
+            this.f = j;
+            return true;
+        } else {
+            return super.c(i, j);
+        }
+    }
+
+    public void y() {
+        this.invalidateBlockCache();
+        super.y();
+    }
+
+    public void c() {
+        ++this.f;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.f);
+    }
+
+    public void d() {
+        --this.f;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.f);
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return this.world.getTileEntity(this.position) != this ? false : entityhuman.d((double) this.position.getX() + 0.5D, (double) this.position.getY() + 0.5D, (double) this.position.getZ() + 0.5D) <= 64.0D;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/VillageDoor.java b/src/main/java/net/minecraft/server/VillageDoor.java
new file mode 100644
index 00000000..33ad5faa
--- /dev/null
+++ b/src/main/java/net/minecraft/server/VillageDoor.java
@@ -0,0 +1,93 @@
+package net.minecraft.server;
+
+public class VillageDoor {
+
+    private final BlockPosition a;
+    private final BlockPosition b;
+    private final EnumDirection c;
+    private int d;
+    private boolean e;
+    private int f;
+
+    public VillageDoor(BlockPosition blockposition, int i, int j, int k) {
+        this(blockposition, a(i, j), k);
+    }
+
+    private static EnumDirection a(int i, int j) {
+        return i < 0 ? EnumDirection.WEST : (i > 0 ? EnumDirection.EAST : (j < 0 ? EnumDirection.NORTH : EnumDirection.SOUTH));
+    }
+
+    public VillageDoor(BlockPosition blockposition, EnumDirection enumdirection, int i) {
+        this.a = blockposition.h();
+        this.c = enumdirection;
+        this.b = blockposition.shift(enumdirection, 2);
+        this.d = i;
+    }
+
+    public int b(int i, int j, int k) {
+        return (int) this.a.distanceSquared((double) i, (double) j, (double) k);
+    }
+
+    public int a(BlockPosition blockposition) {
+        return (int) blockposition.n(this.d());
+    }
+
+    public int b(BlockPosition blockposition) {
+        return (int) this.b.n(blockposition);
+    }
+
+    public boolean c(BlockPosition blockposition) {
+        int i = blockposition.getX() - this.a.getX();
+        int j = blockposition.getZ() - this.a.getY();
+
+        return i * this.c.getAdjacentX() + j * this.c.getAdjacentZ() >= 0;
+    }
+
+    public void a() {
+        this.f = 0;
+    }
+
+    public void b() {
+        ++this.f;
+    }
+
+    public int c() {
+        return this.f;
+    }
+
+    public BlockPosition d() {
+        return this.a;
+    }
+
+    public BlockPosition e() {
+        return this.b;
+    }
+
+    public int f() {
+        return this.c.getAdjacentX() * 2;
+    }
+
+    public int g() {
+        return this.c.getAdjacentZ() * 2;
+    }
+
+    public int h() {
+        return this.d;
+    }
+
+    public void a(int i) {
+        this.d = i;
+    }
+
+    public boolean i() {
+        return this.e;
+    }
+
+    public void a(boolean flag) {
+        this.e = flag;
+    }
+
+    public EnumDirection j() {
+        return this.c;
+    }
+}
-- 
2.21.0

