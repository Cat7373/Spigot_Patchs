From 30affcc1910f95869732efc8b3969d46e3ef8e66 Mon Sep 17 00:00:00 2001
From: Cat73 <cat73@cat73.org>
Date: Sun, 25 Jun 2017 15:19:48 +0800
Subject: [PATCH] Cat73 -> Auto import mc-dev


diff --git a/src/main/java/net/minecraft/server/AxisAlignedBB.java b/src/main/java/net/minecraft/server/AxisAlignedBB.java
new file mode 100644
index 00000000..1eb9c2da
--- /dev/null
+++ b/src/main/java/net/minecraft/server/AxisAlignedBB.java
@@ -0,0 +1,347 @@
+package net.minecraft.server;
+
+import com.google.common.annotations.VisibleForTesting;
+import javax.annotation.Nullable;
+
+public class AxisAlignedBB {
+
+    public final double a;
+    public final double b;
+    public final double c;
+    public final double d;
+    public final double e;
+    public final double f;
+
+    public AxisAlignedBB(double d0, double d1, double d2, double d3, double d4, double d5) {
+        this.a = Math.min(d0, d3);
+        this.b = Math.min(d1, d4);
+        this.c = Math.min(d2, d5);
+        this.d = Math.max(d0, d3);
+        this.e = Math.max(d1, d4);
+        this.f = Math.max(d2, d5);
+    }
+
+    public AxisAlignedBB(BlockPosition blockposition) {
+        this((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), (double) (blockposition.getX() + 1), (double) (blockposition.getY() + 1), (double) (blockposition.getZ() + 1));
+    }
+
+    public AxisAlignedBB(BlockPosition blockposition, BlockPosition blockposition1) {
+        this((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), (double) blockposition1.getX(), (double) blockposition1.getY(), (double) blockposition1.getZ());
+    }
+
+    public AxisAlignedBB e(double d0) {
+        return new AxisAlignedBB(this.a, this.b, this.c, this.d, d0, this.f);
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof AxisAlignedBB)) {
+            return false;
+        } else {
+            AxisAlignedBB axisalignedbb = (AxisAlignedBB) object;
+
+            return Double.compare(axisalignedbb.a, this.a) != 0 ? false : (Double.compare(axisalignedbb.b, this.b) != 0 ? false : (Double.compare(axisalignedbb.c, this.c) != 0 ? false : (Double.compare(axisalignedbb.d, this.d) != 0 ? false : (Double.compare(axisalignedbb.e, this.e) != 0 ? false : Double.compare(axisalignedbb.f, this.f) == 0))));
+        }
+    }
+
+    public int hashCode() {
+        long i = Double.doubleToLongBits(this.a);
+        int j = (int) (i ^ i >>> 32);
+
+        i = Double.doubleToLongBits(this.b);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        i = Double.doubleToLongBits(this.c);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        i = Double.doubleToLongBits(this.d);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        i = Double.doubleToLongBits(this.e);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        i = Double.doubleToLongBits(this.f);
+        j = 31 * j + (int) (i ^ i >>> 32);
+        return j;
+    }
+
+    public AxisAlignedBB a(double d0, double d1, double d2) {
+        double d3 = this.a;
+        double d4 = this.b;
+        double d5 = this.c;
+        double d6 = this.d;
+        double d7 = this.e;
+        double d8 = this.f;
+
+        if (d0 < 0.0D) {
+            d3 -= d0;
+        } else if (d0 > 0.0D) {
+            d6 -= d0;
+        }
+
+        if (d1 < 0.0D) {
+            d4 -= d1;
+        } else if (d1 > 0.0D) {
+            d7 -= d1;
+        }
+
+        if (d2 < 0.0D) {
+            d5 -= d2;
+        } else if (d2 > 0.0D) {
+            d8 -= d2;
+        }
+
+        return new AxisAlignedBB(d3, d4, d5, d6, d7, d8);
+    }
+
+    public AxisAlignedBB b(double d0, double d1, double d2) {
+        double d3 = this.a;
+        double d4 = this.b;
+        double d5 = this.c;
+        double d6 = this.d;
+        double d7 = this.e;
+        double d8 = this.f;
+
+        if (d0 < 0.0D) {
+            d3 += d0;
+        } else if (d0 > 0.0D) {
+            d6 += d0;
+        }
+
+        if (d1 < 0.0D) {
+            d4 += d1;
+        } else if (d1 > 0.0D) {
+            d7 += d1;
+        }
+
+        if (d2 < 0.0D) {
+            d5 += d2;
+        } else if (d2 > 0.0D) {
+            d8 += d2;
+        }
+
+        return new AxisAlignedBB(d3, d4, d5, d6, d7, d8);
+    }
+
+    public AxisAlignedBB grow(double d0, double d1, double d2) {
+        double d3 = this.a - d0;
+        double d4 = this.b - d1;
+        double d5 = this.c - d2;
+        double d6 = this.d + d0;
+        double d7 = this.e + d1;
+        double d8 = this.f + d2;
+
+        return new AxisAlignedBB(d3, d4, d5, d6, d7, d8);
+    }
+
+    public AxisAlignedBB g(double d0) {
+        return this.grow(d0, d0, d0);
+    }
+
+    public AxisAlignedBB a(AxisAlignedBB axisalignedbb) {
+        double d0 = Math.max(this.a, axisalignedbb.a);
+        double d1 = Math.max(this.b, axisalignedbb.b);
+        double d2 = Math.max(this.c, axisalignedbb.c);
+        double d3 = Math.min(this.d, axisalignedbb.d);
+        double d4 = Math.min(this.e, axisalignedbb.e);
+        double d5 = Math.min(this.f, axisalignedbb.f);
+
+        return new AxisAlignedBB(d0, d1, d2, d3, d4, d5);
+    }
+
+    public AxisAlignedBB b(AxisAlignedBB axisalignedbb) {
+        double d0 = Math.min(this.a, axisalignedbb.a);
+        double d1 = Math.min(this.b, axisalignedbb.b);
+        double d2 = Math.min(this.c, axisalignedbb.c);
+        double d3 = Math.max(this.d, axisalignedbb.d);
+        double d4 = Math.max(this.e, axisalignedbb.e);
+        double d5 = Math.max(this.f, axisalignedbb.f);
+
+        return new AxisAlignedBB(d0, d1, d2, d3, d4, d5);
+    }
+
+    public AxisAlignedBB d(double d0, double d1, double d2) {
+        return new AxisAlignedBB(this.a + d0, this.b + d1, this.c + d2, this.d + d0, this.e + d1, this.f + d2);
+    }
+
+    public AxisAlignedBB a(BlockPosition blockposition) {
+        return new AxisAlignedBB(this.a + (double) blockposition.getX(), this.b + (double) blockposition.getY(), this.c + (double) blockposition.getZ(), this.d + (double) blockposition.getX(), this.e + (double) blockposition.getY(), this.f + (double) blockposition.getZ());
+    }
+
+    public AxisAlignedBB a(Vec3D vec3d) {
+        return this.d(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public double a(AxisAlignedBB axisalignedbb, double d0) {
+        if (axisalignedbb.e > this.b && axisalignedbb.b < this.e && axisalignedbb.f > this.c && axisalignedbb.c < this.f) {
+            double d1;
+
+            if (d0 > 0.0D && axisalignedbb.d <= this.a) {
+                d1 = this.a - axisalignedbb.d;
+                if (d1 < d0) {
+                    d0 = d1;
+                }
+            } else if (d0 < 0.0D && axisalignedbb.a >= this.d) {
+                d1 = this.d - axisalignedbb.a;
+                if (d1 > d0) {
+                    d0 = d1;
+                }
+            }
+
+            return d0;
+        } else {
+            return d0;
+        }
+    }
+
+    public double b(AxisAlignedBB axisalignedbb, double d0) {
+        if (axisalignedbb.d > this.a && axisalignedbb.a < this.d && axisalignedbb.f > this.c && axisalignedbb.c < this.f) {
+            double d1;
+
+            if (d0 > 0.0D && axisalignedbb.e <= this.b) {
+                d1 = this.b - axisalignedbb.e;
+                if (d1 < d0) {
+                    d0 = d1;
+                }
+            } else if (d0 < 0.0D && axisalignedbb.b >= this.e) {
+                d1 = this.e - axisalignedbb.b;
+                if (d1 > d0) {
+                    d0 = d1;
+                }
+            }
+
+            return d0;
+        } else {
+            return d0;
+        }
+    }
+
+    public double c(AxisAlignedBB axisalignedbb, double d0) {
+        if (axisalignedbb.d > this.a && axisalignedbb.a < this.d && axisalignedbb.e > this.b && axisalignedbb.b < this.e) {
+            double d1;
+
+            if (d0 > 0.0D && axisalignedbb.f <= this.c) {
+                d1 = this.c - axisalignedbb.f;
+                if (d1 < d0) {
+                    d0 = d1;
+                }
+            } else if (d0 < 0.0D && axisalignedbb.c >= this.f) {
+                d1 = this.f - axisalignedbb.c;
+                if (d1 > d0) {
+                    d0 = d1;
+                }
+            }
+
+            return d0;
+        } else {
+            return d0;
+        }
+    }
+
+    public boolean c(AxisAlignedBB axisalignedbb) {
+        return this.a(axisalignedbb.a, axisalignedbb.b, axisalignedbb.c, axisalignedbb.d, axisalignedbb.e, axisalignedbb.f);
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3, double d4, double d5) {
+        return this.a < d3 && this.d > d0 && this.b < d4 && this.e > d1 && this.c < d5 && this.f > d2;
+    }
+
+    public boolean b(Vec3D vec3d) {
+        return vec3d.x > this.a && vec3d.x < this.d ? (vec3d.y > this.b && vec3d.y < this.e ? vec3d.z > this.c && vec3d.z < this.f : false) : false;
+    }
+
+    public double a() {
+        double d0 = this.d - this.a;
+        double d1 = this.e - this.b;
+        double d2 = this.f - this.c;
+
+        return (d0 + d1 + d2) / 3.0D;
+    }
+
+    public AxisAlignedBB shrink(double d0) {
+        return this.g(-d0);
+    }
+
+    @Nullable
+    public MovingObjectPosition b(Vec3D vec3d, Vec3D vec3d1) {
+        Vec3D vec3d2 = this.a(this.a, vec3d, vec3d1);
+        EnumDirection enumdirection = EnumDirection.WEST;
+        Vec3D vec3d3 = this.a(this.d, vec3d, vec3d1);
+
+        if (vec3d3 != null && this.a(vec3d, vec3d2, vec3d3)) {
+            vec3d2 = vec3d3;
+            enumdirection = EnumDirection.EAST;
+        }
+
+        vec3d3 = this.b(this.b, vec3d, vec3d1);
+        if (vec3d3 != null && this.a(vec3d, vec3d2, vec3d3)) {
+            vec3d2 = vec3d3;
+            enumdirection = EnumDirection.DOWN;
+        }
+
+        vec3d3 = this.b(this.e, vec3d, vec3d1);
+        if (vec3d3 != null && this.a(vec3d, vec3d2, vec3d3)) {
+            vec3d2 = vec3d3;
+            enumdirection = EnumDirection.UP;
+        }
+
+        vec3d3 = this.c(this.c, vec3d, vec3d1);
+        if (vec3d3 != null && this.a(vec3d, vec3d2, vec3d3)) {
+            vec3d2 = vec3d3;
+            enumdirection = EnumDirection.NORTH;
+        }
+
+        vec3d3 = this.c(this.f, vec3d, vec3d1);
+        if (vec3d3 != null && this.a(vec3d, vec3d2, vec3d3)) {
+            vec3d2 = vec3d3;
+            enumdirection = EnumDirection.SOUTH;
+        }
+
+        return vec3d2 == null ? null : new MovingObjectPosition(vec3d2, enumdirection);
+    }
+
+    @VisibleForTesting
+    boolean a(Vec3D vec3d, @Nullable Vec3D vec3d1, Vec3D vec3d2) {
+        return vec3d1 == null || vec3d.distanceSquared(vec3d2) < vec3d.distanceSquared(vec3d1);
+    }
+
+    @Nullable
+    @VisibleForTesting
+    Vec3D a(double d0, Vec3D vec3d, Vec3D vec3d1) {
+        Vec3D vec3d2 = vec3d.a(vec3d1, d0);
+
+        return vec3d2 != null && this.c(vec3d2) ? vec3d2 : null;
+    }
+
+    @Nullable
+    @VisibleForTesting
+    Vec3D b(double d0, Vec3D vec3d, Vec3D vec3d1) {
+        Vec3D vec3d2 = vec3d.b(vec3d1, d0);
+
+        return vec3d2 != null && this.d(vec3d2) ? vec3d2 : null;
+    }
+
+    @Nullable
+    @VisibleForTesting
+    Vec3D c(double d0, Vec3D vec3d, Vec3D vec3d1) {
+        Vec3D vec3d2 = vec3d.c(vec3d1, d0);
+
+        return vec3d2 != null && this.e(vec3d2) ? vec3d2 : null;
+    }
+
+    @VisibleForTesting
+    public boolean c(Vec3D vec3d) {
+        return vec3d.y >= this.b && vec3d.y <= this.e && vec3d.z >= this.c && vec3d.z <= this.f;
+    }
+
+    @VisibleForTesting
+    public boolean d(Vec3D vec3d) {
+        return vec3d.x >= this.a && vec3d.x <= this.d && vec3d.z >= this.c && vec3d.z <= this.f;
+    }
+
+    @VisibleForTesting
+    public boolean e(Vec3D vec3d) {
+        return vec3d.x >= this.a && vec3d.x <= this.d && vec3d.y >= this.b && vec3d.y <= this.e;
+    }
+
+    public String toString() {
+        return "box[" + this.a + ", " + this.b + ", " + this.c + " -> " + this.d + ", " + this.e + ", " + this.f + "]";
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
new file mode 100644
index 00000000..67b476b2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -0,0 +1,421 @@
+package net.minecraft.server;
+
+import com.google.common.collect.AbstractIterator;
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.concurrent.Immutable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+@Immutable
+public class BlockPosition extends BaseBlockPosition {
+
+    private static final Logger b = LogManager.getLogger();
+    public static final BlockPosition ZERO = new BlockPosition(0, 0, 0);
+    private static final int c = 1 + MathHelper.e(MathHelper.c(30000000));
+    private static final int d = BlockPosition.c;
+    private static final int f = 64 - BlockPosition.c - BlockPosition.d;
+    private static final int g = 0 + BlockPosition.d;
+    private static final int h = BlockPosition.g + BlockPosition.f;
+    private static final long i = (1L << BlockPosition.c) - 1L;
+    private static final long j = (1L << BlockPosition.f) - 1L;
+    private static final long k = (1L << BlockPosition.d) - 1L;
+
+    public BlockPosition(int i, int j, int k) {
+        super(i, j, k);
+    }
+
+    public BlockPosition(double d0, double d1, double d2) {
+        super(d0, d1, d2);
+    }
+
+    public BlockPosition(Entity entity) {
+        this(entity.locX, entity.locY, entity.locZ);
+    }
+
+    public BlockPosition(Vec3D vec3d) {
+        this(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public BlockPosition(BaseBlockPosition baseblockposition) {
+        this(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public BlockPosition a(double d0, double d1, double d2) {
+        return d0 == 0.0D && d1 == 0.0D && d2 == 0.0D ? this : new BlockPosition((double) this.getX() + d0, (double) this.getY() + d1, (double) this.getZ() + d2);
+    }
+
+    public BlockPosition a(int i, int j, int k) {
+        return i == 0 && j == 0 && k == 0 ? this : new BlockPosition(this.getX() + i, this.getY() + j, this.getZ() + k);
+    }
+
+    public BlockPosition a(BaseBlockPosition baseblockposition) {
+        return this.a(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public BlockPosition b(BaseBlockPosition baseblockposition) {
+        return this.a(-baseblockposition.getX(), -baseblockposition.getY(), -baseblockposition.getZ());
+    }
+
+    public BlockPosition up() {
+        return this.up(1);
+    }
+
+    public BlockPosition up(int i) {
+        return this.shift(EnumDirection.UP, i);
+    }
+
+    public BlockPosition down() {
+        return this.down(1);
+    }
+
+    public BlockPosition down(int i) {
+        return this.shift(EnumDirection.DOWN, i);
+    }
+
+    public BlockPosition north() {
+        return this.north(1);
+    }
+
+    public BlockPosition north(int i) {
+        return this.shift(EnumDirection.NORTH, i);
+    }
+
+    public BlockPosition south() {
+        return this.south(1);
+    }
+
+    public BlockPosition south(int i) {
+        return this.shift(EnumDirection.SOUTH, i);
+    }
+
+    public BlockPosition west() {
+        return this.west(1);
+    }
+
+    public BlockPosition west(int i) {
+        return this.shift(EnumDirection.WEST, i);
+    }
+
+    public BlockPosition east() {
+        return this.east(1);
+    }
+
+    public BlockPosition east(int i) {
+        return this.shift(EnumDirection.EAST, i);
+    }
+
+    public BlockPosition shift(EnumDirection enumdirection) {
+        return this.shift(enumdirection, 1);
+    }
+
+    public BlockPosition shift(EnumDirection enumdirection, int i) {
+        return i == 0 ? this : new BlockPosition(this.getX() + enumdirection.getAdjacentX() * i, this.getY() + enumdirection.getAdjacentY() * i, this.getZ() + enumdirection.getAdjacentZ() * i);
+    }
+
+    public BlockPosition a(EnumBlockRotation enumblockrotation) {
+        switch (enumblockrotation) {
+        case NONE:
+        default:
+            return this;
+
+        case CLOCKWISE_90:
+            return new BlockPosition(-this.getZ(), this.getY(), this.getX());
+
+        case CLOCKWISE_180:
+            return new BlockPosition(-this.getX(), this.getY(), -this.getZ());
+
+        case COUNTERCLOCKWISE_90:
+            return new BlockPosition(this.getZ(), this.getY(), -this.getX());
+        }
+    }
+
+    public BlockPosition c(BaseBlockPosition baseblockposition) {
+        return new BlockPosition(this.getY() * baseblockposition.getZ() - this.getZ() * baseblockposition.getY(), this.getZ() * baseblockposition.getX() - this.getX() * baseblockposition.getZ(), this.getX() * baseblockposition.getY() - this.getY() * baseblockposition.getX());
+    }
+
+    public long asLong() {
+        return ((long) this.getX() & BlockPosition.i) << BlockPosition.h | ((long) this.getY() & BlockPosition.j) << BlockPosition.g | ((long) this.getZ() & BlockPosition.k) << 0;
+    }
+
+    public static BlockPosition fromLong(long i) {
+        int j = (int) (i << 64 - BlockPosition.h - BlockPosition.c >> 64 - BlockPosition.c);
+        int k = (int) (i << 64 - BlockPosition.g - BlockPosition.f >> 64 - BlockPosition.f);
+        int l = (int) (i << 64 - BlockPosition.d >> 64 - BlockPosition.d);
+
+        return new BlockPosition(j, k, l);
+    }
+
+    public static Iterable<BlockPosition> a(BlockPosition blockposition, BlockPosition blockposition1) {
+        return a(Math.min(blockposition.getX(), blockposition1.getX()), Math.min(blockposition.getY(), blockposition1.getY()), Math.min(blockposition.getZ(), blockposition1.getZ()), Math.max(blockposition.getX(), blockposition1.getX()), Math.max(blockposition.getY(), blockposition1.getY()), Math.max(blockposition.getZ(), blockposition1.getZ()));
+    }
+
+    public static Iterable<BlockPosition> a(final int i, final int j, final int k, final int l, final int i1, final int j1) {
+        return new Iterable() {
+            public Iterator<BlockPosition> iterator() {
+                return new AbstractIterator() {
+                    private boolean b = true;
+                    private int c;
+                    private int d;
+                    private int e;
+
+                    protected BlockPosition a() {
+                        if (this.b) {
+                            this.b = false;
+                            this.c = i;
+                            this.d = j;
+                            this.e = k;
+                            return new BlockPosition(i, j, k);
+                        } else if (this.c == l && this.d == i1 && this.e == j1) {
+                            return (BlockPosition) this.endOfData();
+                        } else {
+                            if (this.c < l) {
+                                ++this.c;
+                            } else if (this.d < i1) {
+                                this.c = i;
+                                ++this.d;
+                            } else if (this.e < j1) {
+                                this.c = i;
+                                this.d = j;
+                                ++this.e;
+                            }
+
+                            return new BlockPosition(this.c, this.d, this.e);
+                        }
+                    }
+
+                    protected Object computeNext() {
+                        return this.a();
+                    }
+                };
+            }
+        };
+    }
+
+    public BlockPosition h() {
+        return this;
+    }
+
+    public static Iterable<BlockPosition.MutableBlockPosition> b(BlockPosition blockposition, BlockPosition blockposition1) {
+        return b(Math.min(blockposition.getX(), blockposition1.getX()), Math.min(blockposition.getY(), blockposition1.getY()), Math.min(blockposition.getZ(), blockposition1.getZ()), Math.max(blockposition.getX(), blockposition1.getX()), Math.max(blockposition.getY(), blockposition1.getY()), Math.max(blockposition.getZ(), blockposition1.getZ()));
+    }
+
+    public static Iterable<BlockPosition.MutableBlockPosition> b(final int i, final int j, final int k, final int l, final int i1, final int j1) {
+        return new Iterable() {
+            public Iterator<BlockPosition.MutableBlockPosition> iterator() {
+                return new AbstractIterator() {
+                    private BlockPosition.MutableBlockPosition b;
+
+                    protected BlockPosition.MutableBlockPosition a() {
+                        if (this.b == null) {
+                            this.b = new BlockPosition.MutableBlockPosition(i, j, k);
+                            return this.b;
+                        } else if (this.b.b == l && this.b.c == i1 && this.b.d == j1) {
+                            return (BlockPosition.MutableBlockPosition) this.endOfData();
+                        } else {
+                            if (this.b.b < l) {
+                                ++this.b.b;
+                            } else if (this.b.c < i1) {
+                                this.b.b = i;
+                                ++this.b.c;
+                            } else if (this.b.d < j1) {
+                                this.b.b = i;
+                                this.b.c = j;
+                                ++this.b.d;
+                            }
+
+                            return this.b;
+                        }
+                    }
+
+                    protected Object computeNext() {
+                        return this.a();
+                    }
+                };
+            }
+        };
+    }
+
+    public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+        return this.c(baseblockposition);
+    }
+
+    public static final class PooledBlockPosition extends BlockPosition.MutableBlockPosition {
+
+        private boolean f;
+        private static final List<BlockPosition.PooledBlockPosition> g = Lists.newArrayList();
+
+        private PooledBlockPosition(int i, int j, int k) {
+            super(i, j, k);
+        }
+
+        public static BlockPosition.PooledBlockPosition s() {
+            return e(0, 0, 0);
+        }
+
+        public static BlockPosition.PooledBlockPosition d(double d0, double d1, double d2) {
+            return e(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+        }
+
+        public static BlockPosition.PooledBlockPosition e(int i, int j, int k) {
+            List list = BlockPosition.PooledBlockPosition.g;
+
+            synchronized (BlockPosition.PooledBlockPosition.g) {
+                if (!BlockPosition.PooledBlockPosition.g.isEmpty()) {
+                    BlockPosition.PooledBlockPosition blockposition_pooledblockposition = (BlockPosition.PooledBlockPosition) BlockPosition.PooledBlockPosition.g.remove(BlockPosition.PooledBlockPosition.g.size() - 1);
+
+                    if (blockposition_pooledblockposition != null && blockposition_pooledblockposition.f) {
+                        blockposition_pooledblockposition.f = false;
+                        blockposition_pooledblockposition.f(i, j, k);
+                        return blockposition_pooledblockposition;
+                    }
+                }
+            }
+
+            return new BlockPosition.PooledBlockPosition(i, j, k);
+        }
+
+        public void t() {
+            List list = BlockPosition.PooledBlockPosition.g;
+
+            synchronized (BlockPosition.PooledBlockPosition.g) {
+                if (BlockPosition.PooledBlockPosition.g.size() < 100) {
+                    BlockPosition.PooledBlockPosition.g.add(this);
+                }
+
+                this.f = true;
+            }
+        }
+
+        public BlockPosition.PooledBlockPosition f(int i, int j, int k) {
+            if (this.f) {
+                BlockPosition.b.error("PooledMutableBlockPosition modified after it was released.", new Throwable());
+                this.f = false;
+            }
+
+            return (BlockPosition.PooledBlockPosition) super.c(i, j, k);
+        }
+
+        public BlockPosition.PooledBlockPosition e(double d0, double d1, double d2) {
+            return (BlockPosition.PooledBlockPosition) super.c(d0, d1, d2);
+        }
+
+        public BlockPosition.PooledBlockPosition j(BaseBlockPosition baseblockposition) {
+            return (BlockPosition.PooledBlockPosition) super.g(baseblockposition);
+        }
+
+        public BlockPosition.PooledBlockPosition d(EnumDirection enumdirection) {
+            return (BlockPosition.PooledBlockPosition) super.c(enumdirection);
+        }
+
+        public BlockPosition.PooledBlockPosition d(EnumDirection enumdirection, int i) {
+            return (BlockPosition.PooledBlockPosition) super.c(enumdirection, i);
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection, int i) {
+            return this.d(enumdirection, i);
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection) {
+            return this.d(enumdirection);
+        }
+
+        public BlockPosition.MutableBlockPosition g(BaseBlockPosition baseblockposition) {
+            return this.j(baseblockposition);
+        }
+
+        public BlockPosition.MutableBlockPosition c(double d0, double d1, double d2) {
+            return this.e(d0, d1, d2);
+        }
+
+        public BlockPosition.MutableBlockPosition c(int i, int j, int k) {
+            return this.f(i, j, k);
+        }
+    }
+
+    public static class MutableBlockPosition extends BlockPosition {
+
+        protected int b;
+        protected int c;
+        protected int d;
+
+        public MutableBlockPosition() {
+            this(0, 0, 0);
+        }
+
+        public MutableBlockPosition(BlockPosition blockposition) {
+            this(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+        }
+
+        public MutableBlockPosition(int i, int j, int k) {
+            super(0, 0, 0);
+            this.b = i;
+            this.c = j;
+            this.d = k;
+        }
+
+        public BlockPosition a(double d0, double d1, double d2) {
+            return super.a(d0, d1, d2).h();
+        }
+
+        public BlockPosition a(int i, int j, int k) {
+            return super.a(i, j, k).h();
+        }
+
+        public BlockPosition shift(EnumDirection enumdirection, int i) {
+            return super.shift(enumdirection, i).h();
+        }
+
+        public BlockPosition a(EnumBlockRotation enumblockrotation) {
+            return super.a(enumblockrotation).h();
+        }
+
+        public int getX() {
+            return this.b;
+        }
+
+        public int getY() {
+            return this.c;
+        }
+
+        public int getZ() {
+            return this.d;
+        }
+
+        public BlockPosition.MutableBlockPosition c(int i, int j, int k) {
+            this.b = i;
+            this.c = j;
+            this.d = k;
+            return this;
+        }
+
+        public BlockPosition.MutableBlockPosition c(double d0, double d1, double d2) {
+            return this.c(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+        }
+
+        public BlockPosition.MutableBlockPosition g(BaseBlockPosition baseblockposition) {
+            return this.c(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection) {
+            return this.c(enumdirection, 1);
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection, int i) {
+            return this.c(this.b + enumdirection.getAdjacentX() * i, this.c + enumdirection.getAdjacentY() * i, this.d + enumdirection.getAdjacentZ() * i);
+        }
+
+        public void p(int i) {
+            this.c = i;
+        }
+
+        public BlockPosition h() {
+            return new BlockPosition(this);
+        }
+
+        public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+            return super.c(baseblockposition);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkCache.java b/src/main/java/net/minecraft/server/ChunkCache.java
new file mode 100644
index 00000000..08b986fd
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkCache.java
@@ -0,0 +1,81 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public class ChunkCache implements IBlockAccess {
+
+    protected int a;
+    protected int b;
+    protected Chunk[][] c;
+    protected boolean d;
+    protected World e;
+
+    public ChunkCache(World world, BlockPosition blockposition, BlockPosition blockposition1, int i) {
+        this.e = world;
+        this.a = blockposition.getX() - i >> 4;
+        this.b = blockposition.getZ() - i >> 4;
+        int j = blockposition1.getX() + i >> 4;
+        int k = blockposition1.getZ() + i >> 4;
+
+        this.c = new Chunk[j - this.a + 1][k - this.b + 1];
+        this.d = true;
+
+        int l;
+        int i1;
+
+        for (l = this.a; l <= j; ++l) {
+            for (i1 = this.b; i1 <= k; ++i1) {
+                this.c[l - this.a][i1 - this.b] = world.getChunkAt(l, i1);
+            }
+        }
+
+        for (l = blockposition.getX() >> 4; l <= blockposition1.getX() >> 4; ++l) {
+            for (i1 = blockposition.getZ() >> 4; i1 <= blockposition1.getZ() >> 4; ++i1) {
+                Chunk chunk = this.c[l - this.a][i1 - this.b];
+
+                if (chunk != null && !chunk.c(blockposition.getY(), blockposition1.getY())) {
+                    this.d = false;
+                }
+            }
+        }
+
+    }
+
+    @Nullable
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        return this.a(blockposition, Chunk.EnumTileEntityState.IMMEDIATE);
+    }
+
+    @Nullable
+    public TileEntity a(BlockPosition blockposition, Chunk.EnumTileEntityState chunk_enumtileentitystate) {
+        int i = (blockposition.getX() >> 4) - this.a;
+        int j = (blockposition.getZ() >> 4) - this.b;
+
+        return this.c[i][j].a(blockposition, chunk_enumtileentitystate);
+    }
+
+    public IBlockData getType(BlockPosition blockposition) {
+        if (blockposition.getY() >= 0 && blockposition.getY() < 256) {
+            int i = (blockposition.getX() >> 4) - this.a;
+            int j = (blockposition.getZ() >> 4) - this.b;
+
+            if (i >= 0 && i < this.c.length && j >= 0 && j < this.c[i].length) {
+                Chunk chunk = this.c[i][j];
+
+                if (chunk != null) {
+                    return chunk.getBlockData(blockposition);
+                }
+            }
+        }
+
+        return Blocks.AIR.getBlockData();
+    }
+
+    public boolean isEmpty(BlockPosition blockposition) {
+        return this.getType(blockposition).getMaterial() == Material.AIR;
+    }
+
+    public int getBlockPower(BlockPosition blockposition, EnumDirection enumdirection) {
+        return this.getType(blockposition).b(this, blockposition, enumdirection);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
new file mode 100644
index 00000000..f3a6799a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -0,0 +1,61 @@
+package net.minecraft.server;
+
+import org.apache.commons.lang3.Validate;
+
+public class DataBits {
+
+    private final long[] a;
+    private final int b;
+    private final long c;
+    private final int d;
+
+    public DataBits(int i, int j) {
+        Validate.inclusiveBetween(1L, 32L, (long) i);
+        this.d = j;
+        this.b = i;
+        this.c = (1L << i) - 1L;
+        this.a = new long[MathHelper.c(j * i, 64) / 64];
+    }
+
+    public void a(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.c, (long) j);
+        int k = i * this.b;
+        int l = k / 64;
+        int i1 = ((i + 1) * this.b - 1) / 64;
+        int j1 = k % 64;
+
+        this.a[l] = this.a[l] & ~(this.c << j1) | ((long) j & this.c) << j1;
+        if (l != i1) {
+            int k1 = 64 - j1;
+            int l1 = this.b - k1;
+
+            this.a[i1] = this.a[i1] >>> l1 << l1 | ((long) j & this.c) >> k1;
+        }
+
+    }
+
+    public int a(int i) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        int j = i * this.b;
+        int k = j / 64;
+        int l = ((i + 1) * this.b - 1) / 64;
+        int i1 = j % 64;
+
+        if (k == l) {
+            return (int) (this.a[k] >>> i1 & this.c);
+        } else {
+            int j1 = 64 - i1;
+
+            return (int) ((this.a[k] >>> i1 | this.a[l] << j1) & this.c);
+        }
+    }
+
+    public long[] a() {
+        return this.a;
+    }
+
+    public int b() {
+        return this.d;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/IHopper.java b/src/main/java/net/minecraft/server/IHopper.java
new file mode 100644
index 00000000..804215a1
--- /dev/null
+++ b/src/main/java/net/minecraft/server/IHopper.java
@@ -0,0 +1,12 @@
+package net.minecraft.server;
+
+public interface IHopper extends IInventory {
+
+    World getWorld();
+
+    double E();
+
+    double F();
+
+    double G();
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityEnderChest.java b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
new file mode 100644
index 00000000..31585757
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
@@ -0,0 +1,87 @@
+package net.minecraft.server;
+
+public class TileEntityEnderChest extends TileEntity implements ITickable {
+
+    public float a;
+    public float f;
+    public int g;
+    private int h;
+
+    public TileEntityEnderChest() {}
+
+    public void e() {
+        if (++this.h % 20 * 4 == 0) {
+            this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.g);
+        }
+
+        this.f = this.a;
+        int i = this.position.getX();
+        int j = this.position.getY();
+        int k = this.position.getZ();
+        float f = 0.1F;
+        double d0;
+
+        if (this.g > 0 && this.a == 0.0F) {
+            double d1 = (double) i + 0.5D;
+
+            d0 = (double) k + 0.5D;
+            this.world.a((EntityHuman) null, d1, (double) j + 0.5D, d0, SoundEffects.aT, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+        }
+
+        if (this.g == 0 && this.a > 0.0F || this.g > 0 && this.a < 1.0F) {
+            float f1 = this.a;
+
+            if (this.g > 0) {
+                this.a += 0.1F;
+            } else {
+                this.a -= 0.1F;
+            }
+
+            if (this.a > 1.0F) {
+                this.a = 1.0F;
+            }
+
+            float f2 = 0.5F;
+
+            if (this.a < 0.5F && f1 >= 0.5F) {
+                d0 = (double) i + 0.5D;
+                double d2 = (double) k + 0.5D;
+
+                this.world.a((EntityHuman) null, d0, (double) j + 0.5D, d2, SoundEffects.aS, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+            }
+
+            if (this.a < 0.0F) {
+                this.a = 0.0F;
+            }
+        }
+
+    }
+
+    public boolean c(int i, int j) {
+        if (i == 1) {
+            this.g = j;
+            return true;
+        } else {
+            return super.c(i, j);
+        }
+    }
+
+    public void z() {
+        this.invalidateBlockCache();
+        super.z();
+    }
+
+    public void a() {
+        ++this.g;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.g);
+    }
+
+    public void f() {
+        --this.g;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.g);
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return this.world.getTileEntity(this.position) != this ? false : entityhuman.d((double) this.position.getX() + 0.5D, (double) this.position.getY() + 0.5D, (double) this.position.getZ() + 0.5D) <= 64.0D;
+    }
+}
diff --git a/src/main/java/org/spigotmc/HopperPusher.java b/src/main/java/org/spigotmc/HopperPusher.java
new file mode 100644
index 00000000..489d5617
--- /dev/null
+++ b/src/main/java/org/spigotmc/HopperPusher.java
@@ -0,0 +1,58 @@
+package org.spigotmc;
+
+import net.minecraft.server.AxisAlignedBB;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.MCUtil;
+import net.minecraft.server.TileEntityHopper;
+import net.minecraft.server.World;
+
+public interface HopperPusher {
+
+    default TileEntityHopper findHopper() {
+        BlockPosition pos = new BlockPosition(getX(), getY(), getZ());
+        int startX = pos.getX() - 1;
+        int endX = pos.getX() + 1;
+        int startY = Math.max(0, pos.getY() - 1);
+        int endY = Math.min(255, pos.getY() + 1);
+        int startZ = pos.getZ() - 1;
+        int endZ = pos.getZ() + 1;
+        BlockPosition.PooledBlockPosition adjacentPos = BlockPosition.PooledBlockPosition.aquire();
+        for (int x = startX; x <= endX; x++) {
+            for (int y = startY; y <= endY; y++) {
+                for (int z = startZ; z <= endZ; z++) {
+                    adjacentPos.setValues(x, y, z);
+                    TileEntityHopper hopper = MCUtil.getHopper(getWorld(), adjacentPos);
+                    if (hopper == null) continue; // Avoid playing with the bounding boxes, if at all possible
+                    AxisAlignedBB hopperBoundingBox = hopper.getHopperLookupBoundingBox();
+                    /*
+                     * Check if the entity's bounding box intersects with the hopper's lookup box.
+                     * This operation doesn't work both ways!
+                     * Make sure you check if the entity's box intersects the hopper's box, not vice versa!
+                     */
+                    if (this.getBoundingBox().intersects(hopperBoundingBox)) {
+                        return hopper;
+                    }
+                }
+            }
+        }
+        adjacentPos.free();
+        return null;
+    }
+
+    boolean acceptItem(TileEntityHopper hopper);
+
+    default boolean tryPutInHopper() {
+        TileEntityHopper hopper = findHopper();
+        return hopper != null && hopper.canAcceptItems() && acceptItem(hopper);
+    }
+
+    AxisAlignedBB getBoundingBox();
+
+    World getWorld();
+
+    double getX();
+
+    double getY();
+
+    double getZ();
+}
-- 
2.13.0

