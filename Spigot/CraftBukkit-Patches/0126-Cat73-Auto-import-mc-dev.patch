From 19e1631c2fde3d29eae819957acd9d98fd37a8c6 Mon Sep 17 00:00:00 2001
From: Cat73 <root@cat73.org>
Date: Sat, 6 Oct 2018 19:47:49 +0800
Subject: [PATCH] Cat73 -> Auto import mc-dev


diff --git a/src/main/java/net/minecraft/server/ChunkCache.java b/src/main/java/net/minecraft/server/ChunkCache.java
new file mode 100644
index 000000000..96c0c762a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkCache.java
@@ -0,0 +1,220 @@
+package net.minecraft.server;
+
+import java.util.function.Predicate;
+import javax.annotation.Nullable;
+
+public class ChunkCache implements IIBlockAccess {
+
+    protected int a;
+    protected int b;
+    protected Chunk[][] c;
+    protected boolean d;
+    protected World e;
+
+    public ChunkCache(World world, BlockPosition blockposition, BlockPosition blockposition1, int i) {
+        this.e = world;
+        this.a = blockposition.getX() - i >> 4;
+        this.b = blockposition.getZ() - i >> 4;
+        int j = blockposition1.getX() + i >> 4;
+        int k = blockposition1.getZ() + i >> 4;
+
+        this.c = new Chunk[j - this.a + 1][k - this.b + 1];
+        this.d = true;
+
+        int l;
+        int i1;
+
+        for (l = this.a; l <= j; ++l) {
+            for (i1 = this.b; i1 <= k; ++i1) {
+                this.c[l - this.a][i1 - this.b] = world.getChunkAt(l, i1);
+            }
+        }
+
+        for (l = blockposition.getX() >> 4; l <= blockposition1.getX() >> 4; ++l) {
+            for (i1 = blockposition.getZ() >> 4; i1 <= blockposition1.getZ() >> 4; ++i1) {
+                Chunk chunk = this.c[l - this.a][i1 - this.b];
+
+                if (chunk != null && !chunk.b(blockposition.getY(), blockposition1.getY())) {
+                    this.d = false;
+                }
+            }
+        }
+
+    }
+
+    @Nullable
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        return this.a(blockposition, Chunk.EnumTileEntityState.IMMEDIATE);
+    }
+
+    @Nullable
+    public TileEntity a(BlockPosition blockposition, Chunk.EnumTileEntityState chunk_enumtileentitystate) {
+        int i = (blockposition.getX() >> 4) - this.a;
+        int j = (blockposition.getZ() >> 4) - this.b;
+
+        return this.c[i][j].a(blockposition, chunk_enumtileentitystate);
+    }
+
+    public float A(BlockPosition blockposition) {
+        return this.e.worldProvider.i()[this.getLightLevel(blockposition)];
+    }
+
+    public int d(BlockPosition blockposition, int i) {
+        if (this.getType(blockposition).c(this, blockposition)) {
+            int j = 0;
+            EnumDirection[] aenumdirection = EnumDirection.values();
+            int k = aenumdirection.length;
+
+            for (int l = 0; l < k; ++l) {
+                EnumDirection enumdirection = aenumdirection[l];
+                int i1 = this.getLightLevel(blockposition.shift(enumdirection), i);
+
+                if (i1 > j) {
+                    j = i1;
+                }
+
+                if (j >= 15) {
+                    return j;
+                }
+            }
+
+            return j;
+        } else {
+            return this.getLightLevel(blockposition, i);
+        }
+    }
+
+    public WorldProvider o() {
+        return this.e.o();
+    }
+
+    public int getLightLevel(BlockPosition blockposition, int i) {
+        if (blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() <= 30000000) {
+            if (blockposition.getY() < 0) {
+                return 0;
+            } else {
+                int j;
+
+                if (blockposition.getY() >= 256) {
+                    j = 15 - i;
+                    if (j < 0) {
+                        j = 0;
+                    }
+
+                    return j;
+                } else {
+                    j = (blockposition.getX() >> 4) - this.a;
+                    int k = (blockposition.getZ() >> 4) - this.b;
+
+                    return this.c[j][k].a(blockposition, i);
+                }
+            }
+        } else {
+            return 15;
+        }
+    }
+
+    public boolean isChunkLoaded(int i, int j, boolean flag) {
+        return this.a(i, j);
+    }
+
+    public boolean e(BlockPosition blockposition) {
+        return false;
+    }
+
+    public boolean a(int i, int j) {
+        int k = i - this.a;
+        int l = j - this.b;
+
+        return k >= 0 && k < this.c.length && l >= 0 && l < this.c[k].length;
+    }
+
+    public int a(HeightMap.Type heightmap_type, int i, int j) {
+        throw new RuntimeException("NOT IMPLEMENTED!");
+    }
+
+    public WorldBorder getWorldBorder() {
+        return this.e.getWorldBorder();
+    }
+
+    public boolean a(@Nullable Entity entity, VoxelShape voxelshape) {
+        throw new RuntimeException("This method should never be called here. No entity logic inside Region");
+    }
+
+    @Nullable
+    public EntityHuman a(double d0, double d1, double d2, double d3, Predicate<Entity> predicate) {
+        throw new RuntimeException("This method should never be called here. No entity logic inside Region");
+    }
+
+    public IBlockData getType(BlockPosition blockposition) {
+        if (blockposition.getY() >= 0 && blockposition.getY() < 256) {
+            int i = (blockposition.getX() >> 4) - this.a;
+            int j = (blockposition.getZ() >> 4) - this.b;
+
+            if (i >= 0 && i < this.c.length && j >= 0 && j < this.c[i].length) {
+                Chunk chunk = this.c[i][j];
+
+                if (chunk != null) {
+                    return chunk.getType(blockposition);
+                }
+            }
+        }
+
+        return Blocks.AIR.getBlockData();
+    }
+
+    public Fluid b(BlockPosition blockposition) {
+        if (blockposition.getY() >= 0 && blockposition.getY() < 256) {
+            int i = (blockposition.getX() >> 4) - this.a;
+            int j = (blockposition.getZ() >> 4) - this.b;
+
+            if (i >= 0 && i < this.c.length && j >= 0 && j < this.c[i].length) {
+                Chunk chunk = this.c[i][j];
+
+                if (chunk != null) {
+                    return chunk.b(blockposition);
+                }
+            }
+        }
+
+        return FluidTypes.a.i();
+    }
+
+    public int c() {
+        return 0;
+    }
+
+    public BiomeBase getBiome(BlockPosition blockposition) {
+        int i = (blockposition.getX() >> 4) - this.a;
+        int j = (blockposition.getZ() >> 4) - this.b;
+
+        return this.c[i][j].getBiome(blockposition);
+    }
+
+    public boolean isEmpty(BlockPosition blockposition) {
+        return this.getType(blockposition).isAir();
+    }
+
+    public int getBrightness(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
+        if (blockposition.getY() >= 0 && blockposition.getY() < 256) {
+            int i = (blockposition.getX() >> 4) - this.a;
+            int j = (blockposition.getZ() >> 4) - this.b;
+
+            return this.c[i][j].getBrightness(enumskyblock, blockposition);
+        } else {
+            return enumskyblock.c;
+        }
+    }
+
+    public int a(BlockPosition blockposition, EnumDirection enumdirection) {
+        return this.getType(blockposition).b((IBlockAccess) this, blockposition, enumdirection);
+    }
+
+    public boolean e() {
+        throw new RuntimeException("Not yet implemented");
+    }
+
+    public int getSeaLevel() {
+        throw new RuntimeException("Not yet implemented");
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
new file mode 100644
index 000000000..d24ec3d53
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -0,0 +1,74 @@
+package net.minecraft.server;
+
+import org.apache.commons.lang3.Validate;
+
+public class DataBits {
+
+    private final long[] a;
+    private final int b;
+    private final long c;
+    private final int d;
+
+    public DataBits(int i, int j) {
+        this(i, j, new long[MathHelper.c(j * i, 64) / 64]);
+    }
+
+    public DataBits(int i, int j, long[] along) {
+        Validate.inclusiveBetween(1L, 32L, (long) i);
+        this.d = j;
+        this.b = i;
+        this.a = along;
+        this.c = (1L << i) - 1L;
+        int k = MathHelper.c(j * i, 64) / 64;
+
+        if (along.length != k) {
+            throw new RuntimeException("Invalid length given for storage, got: " + along.length + " but expected: " + k);
+        }
+    }
+
+    public void a(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.c, (long) j);
+        int k = i * this.b;
+        int l = k / 64;
+        int i1 = ((i + 1) * this.b - 1) / 64;
+        int j1 = k % 64;
+
+        this.a[l] = this.a[l] & ~(this.c << j1) | ((long) j & this.c) << j1;
+        if (l != i1) {
+            int k1 = 64 - j1;
+            int l1 = this.b - k1;
+
+            this.a[i1] = this.a[i1] >>> l1 << l1 | ((long) j & this.c) >> k1;
+        }
+
+    }
+
+    public int a(int i) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        int j = i * this.b;
+        int k = j / 64;
+        int l = ((i + 1) * this.b - 1) / 64;
+        int i1 = j % 64;
+
+        if (k == l) {
+            return (int) (this.a[k] >>> i1 & this.c);
+        } else {
+            int j1 = 64 - i1;
+
+            return (int) ((this.a[k] >>> i1 | this.a[l] << j1) & this.c);
+        }
+    }
+
+    public long[] a() {
+        return this.a;
+    }
+
+    public int b() {
+        return this.d;
+    }
+
+    public int c() {
+        return this.b;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NavigationAbstract.java b/src/main/java/net/minecraft/server/NavigationAbstract.java
new file mode 100644
index 000000000..62cb81516
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NavigationAbstract.java
@@ -0,0 +1,310 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public abstract class NavigationAbstract {
+
+    protected EntityInsentient a;
+    protected World b;
+    @Nullable
+    protected PathEntity c;
+    protected double d;
+    private final AttributeInstance p;
+    protected int e;
+    protected int f;
+    protected Vec3D g;
+    protected Vec3D h;
+    protected long i;
+    protected long j;
+    protected double k;
+    protected float l;
+    protected boolean m;
+    protected long n;
+    protected PathfinderAbstract o;
+    private BlockPosition q;
+    private Pathfinder r;
+
+    public NavigationAbstract(EntityInsentient entityinsentient, World world) {
+        this.g = Vec3D.a;
+        this.h = Vec3D.a;
+        this.l = 0.5F;
+        this.a = entityinsentient;
+        this.b = world;
+        this.p = entityinsentient.getAttributeInstance(GenericAttributes.FOLLOW_RANGE);
+        this.r = this.a();
+    }
+
+    public BlockPosition i() {
+        return this.q;
+    }
+
+    protected abstract Pathfinder a();
+
+    public void a(double d0) {
+        this.d = d0;
+    }
+
+    public float j() {
+        return (float) this.p.getValue();
+    }
+
+    public boolean k() {
+        return this.m;
+    }
+
+    public void l() {
+        if (this.b.getTime() - this.n > 20L) {
+            if (this.q != null) {
+                this.c = null;
+                this.c = this.b(this.q);
+                this.n = this.b.getTime();
+                this.m = false;
+            }
+        } else {
+            this.m = true;
+        }
+
+    }
+
+    @Nullable
+    public final PathEntity a(double d0, double d1, double d2) {
+        return this.b(new BlockPosition(d0, d1, d2));
+    }
+
+    @Nullable
+    public PathEntity b(BlockPosition blockposition) {
+        if (!this.b()) {
+            return null;
+        } else if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+            return this.c;
+        } else {
+            this.q = blockposition;
+            float f = this.j();
+
+            this.b.methodProfiler.a("pathfind");
+            BlockPosition blockposition1 = new BlockPosition(this.a);
+            int i = (int) (f + 8.0F);
+            ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+            PathEntity pathentity = this.r.a(chunkcache, this.a, this.q, f);
+
+            this.b.methodProfiler.e();
+            return pathentity;
+        }
+    }
+
+    @Nullable
+    public PathEntity a(Entity entity) {
+        if (!this.b()) {
+            return null;
+        } else {
+            BlockPosition blockposition = new BlockPosition(entity);
+
+            if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+                return this.c;
+            } else {
+                this.q = blockposition;
+                float f = this.j();
+
+                this.b.methodProfiler.a("pathfind");
+                BlockPosition blockposition1 = (new BlockPosition(this.a)).up();
+                int i = (int) (f + 16.0F);
+                ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+                PathEntity pathentity = this.r.a(chunkcache, this.a, entity, f);
+
+                this.b.methodProfiler.e();
+                return pathentity;
+            }
+        }
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3) {
+        return this.a(this.a(d0, d1, d2), d3);
+    }
+
+    public boolean a(Entity entity, double d0) {
+        PathEntity pathentity = this.a(entity);
+
+        return pathentity != null && this.a(pathentity, d0);
+    }
+
+    public boolean a(@Nullable PathEntity pathentity, double d0) {
+        if (pathentity == null) {
+            this.c = null;
+            return false;
+        } else {
+            if (!pathentity.a(this.c)) {
+                this.c = pathentity;
+            }
+
+            this.E_();
+            if (this.c.d() <= 0) {
+                return false;
+            } else {
+                this.d = d0;
+                Vec3D vec3d = this.c();
+
+                this.f = this.e;
+                this.g = vec3d;
+                return true;
+            }
+        }
+    }
+
+    @Nullable
+    public PathEntity m() {
+        return this.c;
+    }
+
+    public void d() {
+        ++this.e;
+        if (this.m) {
+            this.l();
+        }
+
+        if (!this.p()) {
+            Vec3D vec3d;
+
+            if (this.b()) {
+                this.o();
+            } else if (this.c != null && this.c.e() < this.c.d()) {
+                vec3d = this.c();
+                Vec3D vec3d1 = this.c.a(this.a, this.c.e());
+
+                if (vec3d.y > vec3d1.y && !this.a.onGround && MathHelper.floor(vec3d.x) == MathHelper.floor(vec3d1.x) && MathHelper.floor(vec3d.z) == MathHelper.floor(vec3d1.z)) {
+                    this.c.c(this.c.e() + 1);
+                }
+            }
+
+            this.n();
+            if (!this.p()) {
+                vec3d = this.c.a((Entity) this.a);
+                BlockPosition blockposition = new BlockPosition(vec3d);
+
+                this.a.getControllerMove().a(vec3d.x, this.b.getType(blockposition.down()).isAir() ? vec3d.y : PathfinderNormal.a((IBlockAccess) this.b, blockposition), vec3d.z, this.d);
+            }
+        }
+    }
+
+    protected void n() {}
+
+    protected void o() {
+        Vec3D vec3d = this.c();
+        int i = this.c.d();
+
+        for (int j = this.c.e(); j < this.c.d(); ++j) {
+            if ((double) this.c.a(j).b != Math.floor(vec3d.y)) {
+                i = j;
+                break;
+            }
+        }
+
+        this.l = this.a.width > 0.75F ? this.a.width / 2.0F : 0.75F - this.a.width / 2.0F;
+        Vec3D vec3d1 = this.c.f();
+
+        if (MathHelper.e((float) (this.a.locX - (vec3d1.x + 0.5D))) < this.l && MathHelper.e((float) (this.a.locZ - (vec3d1.z + 0.5D))) < this.l && Math.abs(this.a.locY - vec3d1.y) < 1.0D) {
+            this.c.c(this.c.e() + 1);
+        }
+
+        int k = MathHelper.f(this.a.width);
+        int l = MathHelper.f(this.a.length);
+        int i1 = k;
+
+        for (int j1 = i - 1; j1 >= this.c.e(); --j1) {
+            if (this.a(vec3d, this.c.a(this.a, j1), k, l, i1)) {
+                this.c.c(j1);
+                break;
+            }
+        }
+
+        this.a(vec3d);
+    }
+
+    protected void a(Vec3D vec3d) {
+        if (this.e - this.f > 100) {
+            if (vec3d.distanceSquared(this.g) < 2.25D) {
+                this.q();
+            }
+
+            this.f = this.e;
+            this.g = vec3d;
+        }
+
+        if (this.c != null && !this.c.b()) {
+            Vec3D vec3d1 = this.c.f();
+
+            if (vec3d1.equals(this.h)) {
+                this.i += SystemUtils.b() - this.j;
+            } else {
+                this.h = vec3d1;
+                double d0 = vec3d.f(this.h);
+
+                this.k = this.a.cK() > 0.0F ? d0 / (double) this.a.cK() * 1000.0D : 0.0D;
+            }
+
+            if (this.k > 0.0D && (double) this.i > this.k * 3.0D) {
+                this.h = Vec3D.a;
+                this.i = 0L;
+                this.k = 0.0D;
+                this.q();
+            }
+
+            this.j = SystemUtils.b();
+        }
+
+    }
+
+    public boolean p() {
+        return this.c == null || this.c.b();
+    }
+
+    public void q() {
+        this.c = null;
+    }
+
+    protected abstract Vec3D c();
+
+    protected abstract boolean b();
+
+    protected boolean r() {
+        return this.a.aq() || this.a.ax();
+    }
+
+    protected void E_() {
+        if (this.c != null) {
+            for (int i = 0; i < this.c.d(); ++i) {
+                PathPoint pathpoint = this.c.a(i);
+                PathPoint pathpoint1 = i + 1 < this.c.d() ? this.c.a(i + 1) : null;
+                IBlockData iblockdata = this.b.getType(new BlockPosition(pathpoint.a, pathpoint.b, pathpoint.c));
+                Block block = iblockdata.getBlock();
+
+                if (block == Blocks.CAULDRON) {
+                    this.c.a(i, pathpoint.a(pathpoint.a, pathpoint.b + 1, pathpoint.c));
+                    if (pathpoint1 != null && pathpoint.b >= pathpoint1.b) {
+                        this.c.a(i + 1, pathpoint1.a(pathpoint1.a, pathpoint.b + 1, pathpoint1.c));
+                    }
+                }
+            }
+
+        }
+    }
+
+    protected abstract boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k);
+
+    public boolean a(BlockPosition blockposition) {
+        BlockPosition blockposition1 = blockposition.down();
+
+        return this.b.getType(blockposition1).f(this.b, blockposition1);
+    }
+
+    public PathfinderAbstract s() {
+        return this.o;
+    }
+
+    public void d(boolean flag) {
+        this.o.c(flag);
+    }
+
+    public boolean t() {
+        return this.o.e();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PersistentVillage.java b/src/main/java/net/minecraft/server/PersistentVillage.java
new file mode 100644
index 000000000..98c6bbc18
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PersistentVillage.java
@@ -0,0 +1,268 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+
+public class PersistentVillage extends PersistentBase {
+
+    private World world;
+    private final List<BlockPosition> b = Lists.newArrayList();
+    private final List<VillageDoor> c = Lists.newArrayList();
+    private final List<Village> villages = Lists.newArrayList();
+    private int time;
+
+    public PersistentVillage(String s) {
+        super(s);
+    }
+
+    public PersistentVillage(World world) {
+        super(a(world.worldProvider));
+        this.world = world;
+        this.c();
+    }
+
+    public void a(World world) {
+        this.world = world;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(world);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition) {
+        if (this.b.size() <= 64) {
+            if (!this.d(blockposition)) {
+                this.b.add(blockposition);
+            }
+
+        }
+    }
+
+    public void tick() {
+        ++this.time;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(this.time);
+        }
+
+        this.f();
+        this.g();
+        this.h();
+        if (this.time % 400 == 0) {
+            this.c();
+        }
+
+    }
+
+    private void f() {
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            if (village.g()) {
+                iterator.remove();
+                this.c();
+            }
+        }
+
+    }
+
+    public List<Village> getVillages() {
+        return this.villages;
+    }
+
+    public Village getClosestVillage(BlockPosition blockposition, int i) {
+        Village village = null;
+        double d0 = 3.4028234663852886E38D;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village1 = (Village) iterator.next();
+            double d1 = village1.a().n(blockposition);
+
+            if (d1 < d0) {
+                float f = (float) (i + village1.b());
+
+                if (d1 <= (double) (f * f)) {
+                    village = village1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return village;
+    }
+
+    private void g() {
+        if (!this.b.isEmpty()) {
+            this.b((BlockPosition) this.b.remove(0));
+        }
+    }
+
+    private void h() {
+        for (int i = 0; i < this.c.size(); ++i) {
+            VillageDoor villagedoor = (VillageDoor) this.c.get(i);
+            Village village = this.getClosestVillage(villagedoor.d(), 32);
+
+            if (village == null) {
+                village = new Village(this.world);
+                this.villages.add(village);
+                this.c();
+            }
+
+            village.a(villagedoor);
+        }
+
+        this.c.clear();
+    }
+
+    private void b(BlockPosition blockposition) {
+        boolean flag = true;
+        boolean flag1 = true;
+        boolean flag2 = true;
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+        for (int i = -16; i < 16; ++i) {
+            for (int j = -4; j < 4; ++j) {
+                for (int k = -16; k < 16; ++k) {
+                    blockposition_mutableblockposition.g(blockposition).d(i, j, k);
+                    IBlockData iblockdata = this.world.getType(blockposition_mutableblockposition);
+
+                    if (this.a(iblockdata)) {
+                        VillageDoor villagedoor = this.c(blockposition_mutableblockposition);
+
+                        if (villagedoor == null) {
+                            this.a(iblockdata, blockposition_mutableblockposition);
+                        } else {
+                            villagedoor.a(this.time);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    @Nullable
+    private VillageDoor c(BlockPosition blockposition) {
+        Iterator iterator = this.c.iterator();
+
+        VillageDoor villagedoor;
+
+        do {
+            if (!iterator.hasNext()) {
+                iterator = this.villages.iterator();
+
+                VillageDoor villagedoor1;
+
+                do {
+                    if (!iterator.hasNext()) {
+                        return null;
+                    }
+
+                    Village village = (Village) iterator.next();
+
+                    villagedoor1 = village.e(blockposition);
+                } while (villagedoor1 == null);
+
+                return villagedoor1;
+            }
+
+            villagedoor = (VillageDoor) iterator.next();
+        } while (villagedoor.d().getX() != blockposition.getX() || villagedoor.d().getZ() != blockposition.getZ() || Math.abs(villagedoor.d().getY() - blockposition.getY()) > 1);
+
+        return villagedoor;
+    }
+
+    private void a(IBlockData iblockdata, BlockPosition blockposition) {
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockDoor.FACING);
+        EnumDirection enumdirection1 = enumdirection.opposite();
+        int i = this.a(blockposition, enumdirection, 5);
+        int j = this.a(blockposition, enumdirection1, i + 1);
+
+        if (i != j) {
+            this.c.add(new VillageDoor(blockposition, i < j ? enumdirection : enumdirection1, this.time));
+        }
+
+    }
+
+    private int a(BlockPosition blockposition, EnumDirection enumdirection, int i) {
+        int j = 0;
+
+        for (int k = 1; k <= 5; ++k) {
+            if (this.world.e(blockposition.shift(enumdirection, k))) {
+                ++j;
+                if (j >= i) {
+                    return j;
+                }
+            }
+        }
+
+        return j;
+    }
+
+    private boolean d(BlockPosition blockposition) {
+        Iterator iterator = this.b.iterator();
+
+        BlockPosition blockposition1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            blockposition1 = (BlockPosition) iterator.next();
+        } while (!blockposition1.equals(blockposition));
+
+        return true;
+    }
+
+    private boolean a(IBlockData iblockdata) {
+        return iblockdata.getBlock() instanceof BlockDoor && iblockdata.getMaterial() == Material.WOOD;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        this.time = nbttagcompound.getInt("Tick");
+        NBTTagList nbttaglist = nbttagcompound.getList("Villages", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.getCompound(i);
+            Village village = new Village();
+
+            village.a(nbttagcompound1);
+            this.villages.add(village);
+        }
+
+    }
+
+    public NBTTagCompound b(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("Tick", this.time);
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            village.b(nbttagcompound1);
+            nbttaglist.add((NBTBase) nbttagcompound1);
+        }
+
+        nbttagcompound.set("Villages", nbttaglist);
+        return nbttagcompound;
+    }
+
+    public static String a(WorldProvider worldprovider) {
+        return "villages" + worldprovider.getDimensionManager().d();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityEnderChest.java b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
new file mode 100644
index 000000000..b4d3972c0
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
@@ -0,0 +1,89 @@
+package net.minecraft.server;
+
+public class TileEntityEnderChest extends TileEntity implements ITickable {
+
+    public float a;
+    public float e;
+    public int f;
+    private int g;
+
+    public TileEntityEnderChest() {
+        super(TileEntityTypes.ENDER_CHEST);
+    }
+
+    public void Y_() {
+        if (++this.g % 20 * 4 == 0) {
+            this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.f);
+        }
+
+        this.e = this.a;
+        int i = this.position.getX();
+        int j = this.position.getY();
+        int k = this.position.getZ();
+        float f = 0.1F;
+        double d0;
+
+        if (this.f > 0 && this.a == 0.0F) {
+            double d1 = (double) i + 0.5D;
+
+            d0 = (double) k + 0.5D;
+            this.world.a((EntityHuman) null, d1, (double) j + 0.5D, d0, SoundEffects.BLOCK_ENDER_CHEST_OPEN, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+        }
+
+        if (this.f == 0 && this.a > 0.0F || this.f > 0 && this.a < 1.0F) {
+            float f1 = this.a;
+
+            if (this.f > 0) {
+                this.a += 0.1F;
+            } else {
+                this.a -= 0.1F;
+            }
+
+            if (this.a > 1.0F) {
+                this.a = 1.0F;
+            }
+
+            float f2 = 0.5F;
+
+            if (this.a < 0.5F && f1 >= 0.5F) {
+                d0 = (double) i + 0.5D;
+                double d2 = (double) k + 0.5D;
+
+                this.world.a((EntityHuman) null, d0, (double) j + 0.5D, d2, SoundEffects.BLOCK_ENDER_CHEST_CLOSE, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+            }
+
+            if (this.a < 0.0F) {
+                this.a = 0.0F;
+            }
+        }
+
+    }
+
+    public boolean c(int i, int j) {
+        if (i == 1) {
+            this.f = j;
+            return true;
+        } else {
+            return super.c(i, j);
+        }
+    }
+
+    public void y() {
+        this.invalidateBlockCache();
+        super.y();
+    }
+
+    public void c() {
+        ++this.f;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.f);
+    }
+
+    public void d() {
+        --this.f;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.f);
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return this.world.getTileEntity(this.position) != this ? false : entityhuman.d((double) this.position.getX() + 0.5D, (double) this.position.getY() + 0.5D, (double) this.position.getZ() + 0.5D) <= 64.0D;
+    }
+}
-- 
2.19.1

