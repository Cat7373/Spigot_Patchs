From a2459ca3adf3810be07a962a0d1aa8eaac436830 Mon Sep 17 00:00:00 2001
From: Cat73 <root@cat73.org>
Date: Sat, 10 Aug 2019 14:57:56 +0800
Subject: [PATCH] Cat73 -> Auto import mc-dev


diff --git a/src/main/java/net/minecraft/server/CommandSaveAll.java b/src/main/java/net/minecraft/server/CommandSaveAll.java
new file mode 100644
index 000000000..c76d55060
--- /dev/null
+++ b/src/main/java/net/minecraft/server/CommandSaveAll.java
@@ -0,0 +1,36 @@
+package net.minecraft.server;
+
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+
+public class CommandSaveAll {
+
+    private static final SimpleCommandExceptionType a = new SimpleCommandExceptionType(new ChatMessage("commands.save.failed", new Object[0]));
+
+    public static void a(com.mojang.brigadier.CommandDispatcher<CommandListenerWrapper> com_mojang_brigadier_commanddispatcher) {
+        com_mojang_brigadier_commanddispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) ((LiteralArgumentBuilder) CommandDispatcher.a("save-all").requires((commandlistenerwrapper) -> {
+            return commandlistenerwrapper.hasPermission(4);
+        })).executes((commandcontext) -> {
+            return a((CommandListenerWrapper) commandcontext.getSource(), false);
+        })).then(CommandDispatcher.a("flush").executes((commandcontext) -> {
+            return a((CommandListenerWrapper) commandcontext.getSource(), true);
+        })));
+    }
+
+    private static int a(CommandListenerWrapper commandlistenerwrapper, boolean flag) throws CommandSyntaxException {
+        commandlistenerwrapper.sendMessage(new ChatMessage("commands.save.saving", new Object[0]), false);
+        MinecraftServer minecraftserver = commandlistenerwrapper.getServer();
+
+        minecraftserver.getPlayerList().savePlayers();
+        boolean flag1 = minecraftserver.saveChunks(true, flag, true);
+
+        if (!flag1) {
+            throw CommandSaveAll.a.create();
+        } else {
+            commandlistenerwrapper.sendMessage(new ChatMessage("commands.save.success", new Object[0]), true);
+            return 1;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/CommandStop.java b/src/main/java/net/minecraft/server/CommandStop.java
new file mode 100644
index 000000000..78a41bb51
--- /dev/null
+++ b/src/main/java/net/minecraft/server/CommandStop.java
@@ -0,0 +1,17 @@
+package net.minecraft.server;
+
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
+
+public class CommandStop {
+
+    public static void a(com.mojang.brigadier.CommandDispatcher<CommandListenerWrapper> com_mojang_brigadier_commanddispatcher) {
+        com_mojang_brigadier_commanddispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) CommandDispatcher.a("stop").requires((commandlistenerwrapper) -> {
+            return commandlistenerwrapper.hasPermission(4);
+        })).executes((commandcontext) -> {
+            ((CommandListenerWrapper) commandcontext.getSource()).sendMessage(new ChatMessage("commands.stop.stopping", new Object[0]), true);
+            ((CommandListenerWrapper) commandcontext.getSource()).getServer().safeShutdown(false);
+            return 1;
+        }));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
new file mode 100644
index 000000000..91ebd474a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -0,0 +1,129 @@
+package net.minecraft.server;
+
+import java.util.function.IntConsumer;
+import org.apache.commons.lang3.Validate;
+
+public class DataBits {
+
+    private final long[] a;
+    private final int b;
+    private final long c;
+    private final int d;
+
+    public DataBits(int i, int j) {
+        this(i, j, new long[MathHelper.c(j * i, 64) / 64]);
+    }
+
+    public DataBits(int i, int j, long[] along) {
+        Validate.inclusiveBetween(1L, 32L, (long) i);
+        this.d = j;
+        this.b = i;
+        this.a = along;
+        this.c = (1L << i) - 1L;
+        int k = MathHelper.c(j * i, 64) / 64;
+
+        if (along.length != k) {
+            throw new RuntimeException("Invalid length given for storage, got: " + along.length + " but expected: " + k);
+        }
+    }
+
+    public int a(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.c, (long) j);
+        int k = i * this.b;
+        int l = k >> 6;
+        int i1 = (i + 1) * this.b - 1 >> 6;
+        int j1 = k ^ l << 6;
+        byte b0 = 0;
+        int k1 = b0 | (int) (this.a[l] >>> j1 & this.c);
+
+        this.a[l] = this.a[l] & ~(this.c << j1) | ((long) j & this.c) << j1;
+        if (l != i1) {
+            int l1 = 64 - j1;
+            int i2 = this.b - l1;
+
+            k1 |= (int) (this.a[i1] << l1 & this.c);
+            this.a[i1] = this.a[i1] >>> i2 << i2 | ((long) j & this.c) >> l1;
+        }
+
+        return k1;
+    }
+
+    public void b(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.c, (long) j);
+        int k = i * this.b;
+        int l = k >> 6;
+        int i1 = (i + 1) * this.b - 1 >> 6;
+        int j1 = k ^ l << 6;
+
+        this.a[l] = this.a[l] & ~(this.c << j1) | ((long) j & this.c) << j1;
+        if (l != i1) {
+            int k1 = 64 - j1;
+            int l1 = this.b - k1;
+
+            this.a[i1] = this.a[i1] >>> l1 << l1 | ((long) j & this.c) >> k1;
+        }
+
+    }
+
+    public int a(int i) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        int j = i * this.b;
+        int k = j >> 6;
+        int l = (i + 1) * this.b - 1 >> 6;
+        int i1 = j ^ k << 6;
+
+        if (k == l) {
+            return (int) (this.a[k] >>> i1 & this.c);
+        } else {
+            int j1 = 64 - i1;
+
+            return (int) ((this.a[k] >>> i1 | this.a[l] << j1) & this.c);
+        }
+    }
+
+    public long[] a() {
+        return this.a;
+    }
+
+    public int b() {
+        return this.d;
+    }
+
+    public int c() {
+        return this.b;
+    }
+
+    public void a(IntConsumer intconsumer) {
+        int i = this.a.length;
+
+        if (i != 0) {
+            int j = 0;
+            long k = this.a[0];
+            long l = i > 1 ? this.a[1] : 0L;
+
+            for (int i1 = 0; i1 < this.d; ++i1) {
+                int j1 = i1 * this.b;
+                int k1 = j1 >> 6;
+                int l1 = (i1 + 1) * this.b - 1 >> 6;
+                int i2 = j1 ^ k1 << 6;
+
+                if (k1 != j) {
+                    k = l;
+                    l = k1 + 1 < i ? this.a[k1 + 1] : 0L;
+                    j = k1;
+                }
+
+                if (k1 == l1) {
+                    intconsumer.accept((int) (k >>> i2 & this.c));
+                } else {
+                    int j2 = 64 - i2;
+
+                    intconsumer.accept((int) ((k >>> i2 | l << j2) & this.c));
+                }
+            }
+
+        }
+    }
+}
-- 
2.22.0

