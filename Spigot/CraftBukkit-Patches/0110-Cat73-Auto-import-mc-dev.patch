From a2459ca3adf3810be07a962a0d1aa8eaac436830 Mon Sep 17 00:00:00 2001
From: Cat73 <root@cat73.org>
Date: Sat, 10 Aug 2019 14:57:56 +0800
Subject: [PATCH] Cat73 -> Auto import mc-dev


diff --git a/src/main/java/net/minecraft/server/CommandSaveAll.java b/src/main/java/net/minecraft/server/CommandSaveAll.java
new file mode 100644
index 000000000..c76d55060
--- /dev/null
+++ b/src/main/java/net/minecraft/server/CommandSaveAll.java
@@ -0,0 +1,36 @@
+package net.minecraft.server;
+
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
+import com.mojang.brigadier.exceptions.CommandSyntaxException;
+import com.mojang.brigadier.exceptions.SimpleCommandExceptionType;
+
+public class CommandSaveAll {
+
+    private static final SimpleCommandExceptionType a = new SimpleCommandExceptionType(new ChatMessage("commands.save.failed", new Object[0]));
+
+    public static void a(com.mojang.brigadier.CommandDispatcher<CommandListenerWrapper> com_mojang_brigadier_commanddispatcher) {
+        com_mojang_brigadier_commanddispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) ((LiteralArgumentBuilder) CommandDispatcher.a("save-all").requires((commandlistenerwrapper) -> {
+            return commandlistenerwrapper.hasPermission(4);
+        })).executes((commandcontext) -> {
+            return a((CommandListenerWrapper) commandcontext.getSource(), false);
+        })).then(CommandDispatcher.a("flush").executes((commandcontext) -> {
+            return a((CommandListenerWrapper) commandcontext.getSource(), true);
+        })));
+    }
+
+    private static int a(CommandListenerWrapper commandlistenerwrapper, boolean flag) throws CommandSyntaxException {
+        commandlistenerwrapper.sendMessage(new ChatMessage("commands.save.saving", new Object[0]), false);
+        MinecraftServer minecraftserver = commandlistenerwrapper.getServer();
+
+        minecraftserver.getPlayerList().savePlayers();
+        boolean flag1 = minecraftserver.saveChunks(true, flag, true);
+
+        if (!flag1) {
+            throw CommandSaveAll.a.create();
+        } else {
+            commandlistenerwrapper.sendMessage(new ChatMessage("commands.save.success", new Object[0]), true);
+            return 1;
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/CommandStop.java b/src/main/java/net/minecraft/server/CommandStop.java
new file mode 100644
index 000000000..78a41bb51
--- /dev/null
+++ b/src/main/java/net/minecraft/server/CommandStop.java
@@ -0,0 +1,17 @@
+package net.minecraft.server;
+
+import com.mojang.brigadier.builder.LiteralArgumentBuilder;
+import com.mojang.brigadier.context.CommandContext;
+
+public class CommandStop {
+
+    public static void a(com.mojang.brigadier.CommandDispatcher<CommandListenerWrapper> com_mojang_brigadier_commanddispatcher) {
+        com_mojang_brigadier_commanddispatcher.register((LiteralArgumentBuilder) ((LiteralArgumentBuilder) CommandDispatcher.a("stop").requires((commandlistenerwrapper) -> {
+            return commandlistenerwrapper.hasPermission(4);
+        })).executes((commandcontext) -> {
+            ((CommandListenerWrapper) commandcontext.getSource()).sendMessage(new ChatMessage("commands.stop.stopping", new Object[0]), true);
+            ((CommandListenerWrapper) commandcontext.getSource()).getServer().safeShutdown(false);
+            return 1;
+        }));
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
new file mode 100644
index 000000000..91ebd474a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -0,0 +1,129 @@
+package net.minecraft.server;
+
+import java.util.function.IntConsumer;
+import org.apache.commons.lang3.Validate;
+
+public class DataBits {
+
+    private final long[] a;
+    private final int b;
+    private final long c;
+    private final int d;
+
+    public DataBits(int i, int j) {
+        this(i, j, new long[MathHelper.c(j * i, 64) / 64]);
+    }
+
+    public DataBits(int i, int j, long[] along) {
+        Validate.inclusiveBetween(1L, 32L, (long) i);
+        this.d = j;
+        this.b = i;
+        this.a = along;
+        this.c = (1L << i) - 1L;
+        int k = MathHelper.c(j * i, 64) / 64;
+
+        if (along.length != k) {
+            throw new RuntimeException("Invalid length given for storage, got: " + along.length + " but expected: " + k);
+        }
+    }
+
+    public int a(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.c, (long) j);
+        int k = i * this.b;
+        int l = k >> 6;
+        int i1 = (i + 1) * this.b - 1 >> 6;
+        int j1 = k ^ l << 6;
+        byte b0 = 0;
+        int k1 = b0 | (int) (this.a[l] >>> j1 & this.c);
+
+        this.a[l] = this.a[l] & ~(this.c << j1) | ((long) j & this.c) << j1;
+        if (l != i1) {
+            int l1 = 64 - j1;
+            int i2 = this.b - l1;
+
+            k1 |= (int) (this.a[i1] << l1 & this.c);
+            this.a[i1] = this.a[i1] >>> i2 << i2 | ((long) j & this.c) >> l1;
+        }
+
+        return k1;
+    }
+
+    public void b(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.c, (long) j);
+        int k = i * this.b;
+        int l = k >> 6;
+        int i1 = (i + 1) * this.b - 1 >> 6;
+        int j1 = k ^ l << 6;
+
+        this.a[l] = this.a[l] & ~(this.c << j1) | ((long) j & this.c) << j1;
+        if (l != i1) {
+            int k1 = 64 - j1;
+            int l1 = this.b - k1;
+
+            this.a[i1] = this.a[i1] >>> l1 << l1 | ((long) j & this.c) >> k1;
+        }
+
+    }
+
+    public int a(int i) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        int j = i * this.b;
+        int k = j >> 6;
+        int l = (i + 1) * this.b - 1 >> 6;
+        int i1 = j ^ k << 6;
+
+        if (k == l) {
+            return (int) (this.a[k] >>> i1 & this.c);
+        } else {
+            int j1 = 64 - i1;
+
+            return (int) ((this.a[k] >>> i1 | this.a[l] << j1) & this.c);
+        }
+    }
+
+    public long[] a() {
+        return this.a;
+    }
+
+    public int b() {
+        return this.d;
+    }
+
+    public int c() {
+        return this.b;
+    }
+
+    public void a(IntConsumer intconsumer) {
+        int i = this.a.length;
+
+        if (i != 0) {
+            int j = 0;
+            long k = this.a[0];
+            long l = i > 1 ? this.a[1] : 0L;
+
+            for (int i1 = 0; i1 < this.d; ++i1) {
+                int j1 = i1 * this.b;
+                int k1 = j1 >> 6;
+                int l1 = (i1 + 1) * this.b - 1 >> 6;
+                int i2 = j1 ^ k1 << 6;
+
+                if (k1 != j) {
+                    k = l;
+                    l = k1 + 1 < i ? this.a[k1 + 1] : 0L;
+                    j = k1;
+                }
+
+                if (k1 == l1) {
+                    intconsumer.accept((int) (k >>> i2 & this.c));
+                } else {
+                    int j2 = 64 - i2;
+
+                    intconsumer.accept((int) ((k >>> i2 | l << j2) & this.c));
+                }
+            }
+
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/RemoteControlSession.java b/src/main/java/net/minecraft/server/RemoteControlSession.java
new file mode 100644
index 000000000..773f8ef3a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/RemoteControlSession.java
@@ -0,0 +1,155 @@
+package net.minecraft.server;
+
+import java.io.BufferedInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.net.Socket;
+import java.net.SocketTimeoutException;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class RemoteControlSession extends RemoteConnectionThread {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+    private boolean i;
+    private Socket j;
+    private final byte[] k = new byte[1460];
+    private final String l;
+
+    RemoteControlSession(IMinecraftServer iminecraftserver, String s, Socket socket) {
+        super(iminecraftserver, "RCON Client");
+        this.j = socket;
+
+        try {
+            this.j.setSoTimeout(0);
+        } catch (Exception exception) {
+            this.a = false;
+        }
+
+        this.l = s;
+        this.b("Rcon connection from: " + socket.getInetAddress());
+    }
+
+    public void run() {
+        while (true) {
+            try {
+                if (!this.a) {
+                    return;
+                }
+
+                BufferedInputStream bufferedinputstream = new BufferedInputStream(this.j.getInputStream());
+                int i = bufferedinputstream.read(this.k, 0, 1460);
+
+                if (10 > i) {
+                    return;
+                }
+
+                byte b0 = 0;
+                int j = StatusChallengeUtils.b(this.k, 0, i);
+
+                if (j == i - 4) {
+                    int k = b0 + 4;
+                    int l = StatusChallengeUtils.b(this.k, k, i);
+
+                    k += 4;
+                    int i1 = StatusChallengeUtils.a(this.k, k);
+
+                    k += 4;
+                    switch (i1) {
+                        case 2:
+                            if (this.i) {
+                                String s = StatusChallengeUtils.a(this.k, k, i);
+
+                                try {
+                                    this.a(l, this.b.executeRemoteCommand(s));
+                                } catch (Exception exception) {
+                                    this.a(l, "Error executing: " + s + " (" + exception.getMessage() + ")");
+                                }
+                                continue;
+                            }
+
+                            this.f();
+                            continue;
+                        case 3:
+                            String s1 = StatusChallengeUtils.a(this.k, k, i);
+                            int j1 = k + s1.length();
+
+                            if (!s1.isEmpty() && s1.equals(this.l)) {
+                                this.i = true;
+                                this.a(l, 2, "");
+                                continue;
+                            }
+
+                            this.i = false;
+                            this.f();
+                            continue;
+                        default:
+                            this.a(l, String.format("Unknown request %s", Integer.toHexString(i1)));
+                            continue;
+                    }
+                }
+            } catch (SocketTimeoutException sockettimeoutexception) {
+                return;
+            } catch (IOException ioexception) {
+                return;
+            } catch (Exception exception1) {
+                RemoteControlSession.LOGGER.error("Exception whilst parsing RCON input", exception1);
+                return;
+            } finally {
+                this.g();
+            }
+
+            return;
+        }
+    }
+
+    private void a(int i, int j, String s) throws IOException {
+        ByteArrayOutputStream bytearrayoutputstream = new ByteArrayOutputStream(1248);
+        DataOutputStream dataoutputstream = new DataOutputStream(bytearrayoutputstream);
+        byte[] abyte = s.getBytes("UTF-8");
+
+        dataoutputstream.writeInt(Integer.reverseBytes(abyte.length + 10));
+        dataoutputstream.writeInt(Integer.reverseBytes(i));
+        dataoutputstream.writeInt(Integer.reverseBytes(j));
+        dataoutputstream.write(abyte);
+        dataoutputstream.write(0);
+        dataoutputstream.write(0);
+        this.j.getOutputStream().write(bytearrayoutputstream.toByteArray());
+    }
+
+    private void f() throws IOException {
+        this.a(-1, 2, "");
+    }
+
+    private void a(int i, String s) throws IOException {
+        int j = s.length();
+
+        do {
+            int k = 4096 <= j ? 4096 : j;
+
+            this.a(i, 0, s.substring(0, k));
+            s = s.substring(k);
+            j = s.length();
+        } while (0 != j);
+
+    }
+
+    @Override
+    public void b() {
+        super.b();
+        this.g();
+    }
+
+    private void g() {
+        if (null != this.j) {
+            try {
+                this.j.close();
+            } catch (IOException ioexception) {
+                this.c("IO: " + ioexception.getMessage());
+            }
+
+            this.j = null;
+        }
+    }
+}
-- 
2.22.0

