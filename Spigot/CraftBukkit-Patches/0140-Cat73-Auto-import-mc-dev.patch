From 7cd88d45fe088af45fa6189cb3decc88980e0dfc Mon Sep 17 00:00:00 2001
From: Cat73 <cat7373x@gmail.com>
Date: Sun, 17 Jun 2018 14:09:27 +0800
Subject: [PATCH] Cat73 -> Auto import mc-dev


diff --git a/src/main/java/net/minecraft/server/BaseBlockPosition.java b/src/main/java/net/minecraft/server/BaseBlockPosition.java
new file mode 100644
index 00000000..d4f41274
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BaseBlockPosition.java
@@ -0,0 +1,95 @@
+package net.minecraft.server;
+
+import com.google.common.base.MoreObjects;
+import javax.annotation.concurrent.Immutable;
+
+@Immutable
+public class BaseBlockPosition implements Comparable<BaseBlockPosition> {
+
+    public static final BaseBlockPosition ZERO = new BaseBlockPosition(0, 0, 0);
+    private final int a;
+    private final int b;
+    private final int c;
+
+    public BaseBlockPosition(int i, int j, int k) {
+        this.a = i;
+        this.b = j;
+        this.c = k;
+    }
+
+    public BaseBlockPosition(double d0, double d1, double d2) {
+        this(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+    }
+
+    public boolean equals(Object object) {
+        if (this == object) {
+            return true;
+        } else if (!(object instanceof BaseBlockPosition)) {
+            return false;
+        } else {
+            BaseBlockPosition baseblockposition = (BaseBlockPosition) object;
+
+            return this.getX() != baseblockposition.getX() ? false : (this.getY() != baseblockposition.getY() ? false : this.getZ() == baseblockposition.getZ());
+        }
+    }
+
+    public int hashCode() {
+        return (this.getY() + this.getZ() * 31) * 31 + this.getX();
+    }
+
+    public int l(BaseBlockPosition baseblockposition) {
+        return this.getY() == baseblockposition.getY() ? (this.getZ() == baseblockposition.getZ() ? this.getX() - baseblockposition.getX() : this.getZ() - baseblockposition.getZ()) : this.getY() - baseblockposition.getY();
+    }
+
+    public int getX() {
+        return this.a;
+    }
+
+    public int getY() {
+        return this.b;
+    }
+
+    public int getZ() {
+        return this.c;
+    }
+
+    public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+        return new BaseBlockPosition(this.getY() * baseblockposition.getZ() - this.getZ() * baseblockposition.getY(), this.getZ() * baseblockposition.getX() - this.getX() * baseblockposition.getZ(), this.getX() * baseblockposition.getY() - this.getY() * baseblockposition.getX());
+    }
+
+    public double h(int i, int j, int k) {
+        double d0 = (double) (this.getX() - i);
+        double d1 = (double) (this.getY() - j);
+        double d2 = (double) (this.getZ() - k);
+
+        return Math.sqrt(d0 * d0 + d1 * d1 + d2 * d2);
+    }
+
+    public double distanceSquared(double d0, double d1, double d2) {
+        double d3 = (double) this.getX() - d0;
+        double d4 = (double) this.getY() - d1;
+        double d5 = (double) this.getZ() - d2;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
+    }
+
+    public double g(double d0, double d1, double d2) {
+        double d3 = (double) this.getX() + 0.5D - d0;
+        double d4 = (double) this.getY() + 0.5D - d1;
+        double d5 = (double) this.getZ() + 0.5D - d2;
+
+        return d3 * d3 + d4 * d4 + d5 * d5;
+    }
+
+    public double n(BaseBlockPosition baseblockposition) {
+        return this.distanceSquared((double) baseblockposition.getX(), (double) baseblockposition.getY(), (double) baseblockposition.getZ());
+    }
+
+    public String toString() {
+        return MoreObjects.toStringHelper(this).add("x", this.getX()).add("y", this.getY()).add("z", this.getZ()).toString();
+    }
+
+    public int compareTo(Object object) {
+        return this.l((BaseBlockPosition) object);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/BlockPosition.java b/src/main/java/net/minecraft/server/BlockPosition.java
new file mode 100644
index 00000000..67b476b2
--- /dev/null
+++ b/src/main/java/net/minecraft/server/BlockPosition.java
@@ -0,0 +1,421 @@
+package net.minecraft.server;
+
+import com.google.common.collect.AbstractIterator;
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.concurrent.Immutable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+@Immutable
+public class BlockPosition extends BaseBlockPosition {
+
+    private static final Logger b = LogManager.getLogger();
+    public static final BlockPosition ZERO = new BlockPosition(0, 0, 0);
+    private static final int c = 1 + MathHelper.e(MathHelper.c(30000000));
+    private static final int d = BlockPosition.c;
+    private static final int f = 64 - BlockPosition.c - BlockPosition.d;
+    private static final int g = 0 + BlockPosition.d;
+    private static final int h = BlockPosition.g + BlockPosition.f;
+    private static final long i = (1L << BlockPosition.c) - 1L;
+    private static final long j = (1L << BlockPosition.f) - 1L;
+    private static final long k = (1L << BlockPosition.d) - 1L;
+
+    public BlockPosition(int i, int j, int k) {
+        super(i, j, k);
+    }
+
+    public BlockPosition(double d0, double d1, double d2) {
+        super(d0, d1, d2);
+    }
+
+    public BlockPosition(Entity entity) {
+        this(entity.locX, entity.locY, entity.locZ);
+    }
+
+    public BlockPosition(Vec3D vec3d) {
+        this(vec3d.x, vec3d.y, vec3d.z);
+    }
+
+    public BlockPosition(BaseBlockPosition baseblockposition) {
+        this(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public BlockPosition a(double d0, double d1, double d2) {
+        return d0 == 0.0D && d1 == 0.0D && d2 == 0.0D ? this : new BlockPosition((double) this.getX() + d0, (double) this.getY() + d1, (double) this.getZ() + d2);
+    }
+
+    public BlockPosition a(int i, int j, int k) {
+        return i == 0 && j == 0 && k == 0 ? this : new BlockPosition(this.getX() + i, this.getY() + j, this.getZ() + k);
+    }
+
+    public BlockPosition a(BaseBlockPosition baseblockposition) {
+        return this.a(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+    }
+
+    public BlockPosition b(BaseBlockPosition baseblockposition) {
+        return this.a(-baseblockposition.getX(), -baseblockposition.getY(), -baseblockposition.getZ());
+    }
+
+    public BlockPosition up() {
+        return this.up(1);
+    }
+
+    public BlockPosition up(int i) {
+        return this.shift(EnumDirection.UP, i);
+    }
+
+    public BlockPosition down() {
+        return this.down(1);
+    }
+
+    public BlockPosition down(int i) {
+        return this.shift(EnumDirection.DOWN, i);
+    }
+
+    public BlockPosition north() {
+        return this.north(1);
+    }
+
+    public BlockPosition north(int i) {
+        return this.shift(EnumDirection.NORTH, i);
+    }
+
+    public BlockPosition south() {
+        return this.south(1);
+    }
+
+    public BlockPosition south(int i) {
+        return this.shift(EnumDirection.SOUTH, i);
+    }
+
+    public BlockPosition west() {
+        return this.west(1);
+    }
+
+    public BlockPosition west(int i) {
+        return this.shift(EnumDirection.WEST, i);
+    }
+
+    public BlockPosition east() {
+        return this.east(1);
+    }
+
+    public BlockPosition east(int i) {
+        return this.shift(EnumDirection.EAST, i);
+    }
+
+    public BlockPosition shift(EnumDirection enumdirection) {
+        return this.shift(enumdirection, 1);
+    }
+
+    public BlockPosition shift(EnumDirection enumdirection, int i) {
+        return i == 0 ? this : new BlockPosition(this.getX() + enumdirection.getAdjacentX() * i, this.getY() + enumdirection.getAdjacentY() * i, this.getZ() + enumdirection.getAdjacentZ() * i);
+    }
+
+    public BlockPosition a(EnumBlockRotation enumblockrotation) {
+        switch (enumblockrotation) {
+        case NONE:
+        default:
+            return this;
+
+        case CLOCKWISE_90:
+            return new BlockPosition(-this.getZ(), this.getY(), this.getX());
+
+        case CLOCKWISE_180:
+            return new BlockPosition(-this.getX(), this.getY(), -this.getZ());
+
+        case COUNTERCLOCKWISE_90:
+            return new BlockPosition(this.getZ(), this.getY(), -this.getX());
+        }
+    }
+
+    public BlockPosition c(BaseBlockPosition baseblockposition) {
+        return new BlockPosition(this.getY() * baseblockposition.getZ() - this.getZ() * baseblockposition.getY(), this.getZ() * baseblockposition.getX() - this.getX() * baseblockposition.getZ(), this.getX() * baseblockposition.getY() - this.getY() * baseblockposition.getX());
+    }
+
+    public long asLong() {
+        return ((long) this.getX() & BlockPosition.i) << BlockPosition.h | ((long) this.getY() & BlockPosition.j) << BlockPosition.g | ((long) this.getZ() & BlockPosition.k) << 0;
+    }
+
+    public static BlockPosition fromLong(long i) {
+        int j = (int) (i << 64 - BlockPosition.h - BlockPosition.c >> 64 - BlockPosition.c);
+        int k = (int) (i << 64 - BlockPosition.g - BlockPosition.f >> 64 - BlockPosition.f);
+        int l = (int) (i << 64 - BlockPosition.d >> 64 - BlockPosition.d);
+
+        return new BlockPosition(j, k, l);
+    }
+
+    public static Iterable<BlockPosition> a(BlockPosition blockposition, BlockPosition blockposition1) {
+        return a(Math.min(blockposition.getX(), blockposition1.getX()), Math.min(blockposition.getY(), blockposition1.getY()), Math.min(blockposition.getZ(), blockposition1.getZ()), Math.max(blockposition.getX(), blockposition1.getX()), Math.max(blockposition.getY(), blockposition1.getY()), Math.max(blockposition.getZ(), blockposition1.getZ()));
+    }
+
+    public static Iterable<BlockPosition> a(final int i, final int j, final int k, final int l, final int i1, final int j1) {
+        return new Iterable() {
+            public Iterator<BlockPosition> iterator() {
+                return new AbstractIterator() {
+                    private boolean b = true;
+                    private int c;
+                    private int d;
+                    private int e;
+
+                    protected BlockPosition a() {
+                        if (this.b) {
+                            this.b = false;
+                            this.c = i;
+                            this.d = j;
+                            this.e = k;
+                            return new BlockPosition(i, j, k);
+                        } else if (this.c == l && this.d == i1 && this.e == j1) {
+                            return (BlockPosition) this.endOfData();
+                        } else {
+                            if (this.c < l) {
+                                ++this.c;
+                            } else if (this.d < i1) {
+                                this.c = i;
+                                ++this.d;
+                            } else if (this.e < j1) {
+                                this.c = i;
+                                this.d = j;
+                                ++this.e;
+                            }
+
+                            return new BlockPosition(this.c, this.d, this.e);
+                        }
+                    }
+
+                    protected Object computeNext() {
+                        return this.a();
+                    }
+                };
+            }
+        };
+    }
+
+    public BlockPosition h() {
+        return this;
+    }
+
+    public static Iterable<BlockPosition.MutableBlockPosition> b(BlockPosition blockposition, BlockPosition blockposition1) {
+        return b(Math.min(blockposition.getX(), blockposition1.getX()), Math.min(blockposition.getY(), blockposition1.getY()), Math.min(blockposition.getZ(), blockposition1.getZ()), Math.max(blockposition.getX(), blockposition1.getX()), Math.max(blockposition.getY(), blockposition1.getY()), Math.max(blockposition.getZ(), blockposition1.getZ()));
+    }
+
+    public static Iterable<BlockPosition.MutableBlockPosition> b(final int i, final int j, final int k, final int l, final int i1, final int j1) {
+        return new Iterable() {
+            public Iterator<BlockPosition.MutableBlockPosition> iterator() {
+                return new AbstractIterator() {
+                    private BlockPosition.MutableBlockPosition b;
+
+                    protected BlockPosition.MutableBlockPosition a() {
+                        if (this.b == null) {
+                            this.b = new BlockPosition.MutableBlockPosition(i, j, k);
+                            return this.b;
+                        } else if (this.b.b == l && this.b.c == i1 && this.b.d == j1) {
+                            return (BlockPosition.MutableBlockPosition) this.endOfData();
+                        } else {
+                            if (this.b.b < l) {
+                                ++this.b.b;
+                            } else if (this.b.c < i1) {
+                                this.b.b = i;
+                                ++this.b.c;
+                            } else if (this.b.d < j1) {
+                                this.b.b = i;
+                                this.b.c = j;
+                                ++this.b.d;
+                            }
+
+                            return this.b;
+                        }
+                    }
+
+                    protected Object computeNext() {
+                        return this.a();
+                    }
+                };
+            }
+        };
+    }
+
+    public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+        return this.c(baseblockposition);
+    }
+
+    public static final class PooledBlockPosition extends BlockPosition.MutableBlockPosition {
+
+        private boolean f;
+        private static final List<BlockPosition.PooledBlockPosition> g = Lists.newArrayList();
+
+        private PooledBlockPosition(int i, int j, int k) {
+            super(i, j, k);
+        }
+
+        public static BlockPosition.PooledBlockPosition s() {
+            return e(0, 0, 0);
+        }
+
+        public static BlockPosition.PooledBlockPosition d(double d0, double d1, double d2) {
+            return e(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+        }
+
+        public static BlockPosition.PooledBlockPosition e(int i, int j, int k) {
+            List list = BlockPosition.PooledBlockPosition.g;
+
+            synchronized (BlockPosition.PooledBlockPosition.g) {
+                if (!BlockPosition.PooledBlockPosition.g.isEmpty()) {
+                    BlockPosition.PooledBlockPosition blockposition_pooledblockposition = (BlockPosition.PooledBlockPosition) BlockPosition.PooledBlockPosition.g.remove(BlockPosition.PooledBlockPosition.g.size() - 1);
+
+                    if (blockposition_pooledblockposition != null && blockposition_pooledblockposition.f) {
+                        blockposition_pooledblockposition.f = false;
+                        blockposition_pooledblockposition.f(i, j, k);
+                        return blockposition_pooledblockposition;
+                    }
+                }
+            }
+
+            return new BlockPosition.PooledBlockPosition(i, j, k);
+        }
+
+        public void t() {
+            List list = BlockPosition.PooledBlockPosition.g;
+
+            synchronized (BlockPosition.PooledBlockPosition.g) {
+                if (BlockPosition.PooledBlockPosition.g.size() < 100) {
+                    BlockPosition.PooledBlockPosition.g.add(this);
+                }
+
+                this.f = true;
+            }
+        }
+
+        public BlockPosition.PooledBlockPosition f(int i, int j, int k) {
+            if (this.f) {
+                BlockPosition.b.error("PooledMutableBlockPosition modified after it was released.", new Throwable());
+                this.f = false;
+            }
+
+            return (BlockPosition.PooledBlockPosition) super.c(i, j, k);
+        }
+
+        public BlockPosition.PooledBlockPosition e(double d0, double d1, double d2) {
+            return (BlockPosition.PooledBlockPosition) super.c(d0, d1, d2);
+        }
+
+        public BlockPosition.PooledBlockPosition j(BaseBlockPosition baseblockposition) {
+            return (BlockPosition.PooledBlockPosition) super.g(baseblockposition);
+        }
+
+        public BlockPosition.PooledBlockPosition d(EnumDirection enumdirection) {
+            return (BlockPosition.PooledBlockPosition) super.c(enumdirection);
+        }
+
+        public BlockPosition.PooledBlockPosition d(EnumDirection enumdirection, int i) {
+            return (BlockPosition.PooledBlockPosition) super.c(enumdirection, i);
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection, int i) {
+            return this.d(enumdirection, i);
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection) {
+            return this.d(enumdirection);
+        }
+
+        public BlockPosition.MutableBlockPosition g(BaseBlockPosition baseblockposition) {
+            return this.j(baseblockposition);
+        }
+
+        public BlockPosition.MutableBlockPosition c(double d0, double d1, double d2) {
+            return this.e(d0, d1, d2);
+        }
+
+        public BlockPosition.MutableBlockPosition c(int i, int j, int k) {
+            return this.f(i, j, k);
+        }
+    }
+
+    public static class MutableBlockPosition extends BlockPosition {
+
+        protected int b;
+        protected int c;
+        protected int d;
+
+        public MutableBlockPosition() {
+            this(0, 0, 0);
+        }
+
+        public MutableBlockPosition(BlockPosition blockposition) {
+            this(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+        }
+
+        public MutableBlockPosition(int i, int j, int k) {
+            super(0, 0, 0);
+            this.b = i;
+            this.c = j;
+            this.d = k;
+        }
+
+        public BlockPosition a(double d0, double d1, double d2) {
+            return super.a(d0, d1, d2).h();
+        }
+
+        public BlockPosition a(int i, int j, int k) {
+            return super.a(i, j, k).h();
+        }
+
+        public BlockPosition shift(EnumDirection enumdirection, int i) {
+            return super.shift(enumdirection, i).h();
+        }
+
+        public BlockPosition a(EnumBlockRotation enumblockrotation) {
+            return super.a(enumblockrotation).h();
+        }
+
+        public int getX() {
+            return this.b;
+        }
+
+        public int getY() {
+            return this.c;
+        }
+
+        public int getZ() {
+            return this.d;
+        }
+
+        public BlockPosition.MutableBlockPosition c(int i, int j, int k) {
+            this.b = i;
+            this.c = j;
+            this.d = k;
+            return this;
+        }
+
+        public BlockPosition.MutableBlockPosition c(double d0, double d1, double d2) {
+            return this.c(MathHelper.floor(d0), MathHelper.floor(d1), MathHelper.floor(d2));
+        }
+
+        public BlockPosition.MutableBlockPosition g(BaseBlockPosition baseblockposition) {
+            return this.c(baseblockposition.getX(), baseblockposition.getY(), baseblockposition.getZ());
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection) {
+            return this.c(enumdirection, 1);
+        }
+
+        public BlockPosition.MutableBlockPosition c(EnumDirection enumdirection, int i) {
+            return this.c(this.b + enumdirection.getAdjacentX() * i, this.c + enumdirection.getAdjacentY() * i, this.d + enumdirection.getAdjacentZ() * i);
+        }
+
+        public void p(int i) {
+            this.c = i;
+        }
+
+        public BlockPosition h() {
+            return new BlockPosition(this);
+        }
+
+        public BaseBlockPosition d(BaseBlockPosition baseblockposition) {
+            return super.c(baseblockposition);
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/server/ChunkCache.java b/src/main/java/net/minecraft/server/ChunkCache.java
new file mode 100644
index 00000000..08b986fd
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkCache.java
@@ -0,0 +1,81 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public class ChunkCache implements IBlockAccess {
+
+    protected int a;
+    protected int b;
+    protected Chunk[][] c;
+    protected boolean d;
+    protected World e;
+
+    public ChunkCache(World world, BlockPosition blockposition, BlockPosition blockposition1, int i) {
+        this.e = world;
+        this.a = blockposition.getX() - i >> 4;
+        this.b = blockposition.getZ() - i >> 4;
+        int j = blockposition1.getX() + i >> 4;
+        int k = blockposition1.getZ() + i >> 4;
+
+        this.c = new Chunk[j - this.a + 1][k - this.b + 1];
+        this.d = true;
+
+        int l;
+        int i1;
+
+        for (l = this.a; l <= j; ++l) {
+            for (i1 = this.b; i1 <= k; ++i1) {
+                this.c[l - this.a][i1 - this.b] = world.getChunkAt(l, i1);
+            }
+        }
+
+        for (l = blockposition.getX() >> 4; l <= blockposition1.getX() >> 4; ++l) {
+            for (i1 = blockposition.getZ() >> 4; i1 <= blockposition1.getZ() >> 4; ++i1) {
+                Chunk chunk = this.c[l - this.a][i1 - this.b];
+
+                if (chunk != null && !chunk.c(blockposition.getY(), blockposition1.getY())) {
+                    this.d = false;
+                }
+            }
+        }
+
+    }
+
+    @Nullable
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        return this.a(blockposition, Chunk.EnumTileEntityState.IMMEDIATE);
+    }
+
+    @Nullable
+    public TileEntity a(BlockPosition blockposition, Chunk.EnumTileEntityState chunk_enumtileentitystate) {
+        int i = (blockposition.getX() >> 4) - this.a;
+        int j = (blockposition.getZ() >> 4) - this.b;
+
+        return this.c[i][j].a(blockposition, chunk_enumtileentitystate);
+    }
+
+    public IBlockData getType(BlockPosition blockposition) {
+        if (blockposition.getY() >= 0 && blockposition.getY() < 256) {
+            int i = (blockposition.getX() >> 4) - this.a;
+            int j = (blockposition.getZ() >> 4) - this.b;
+
+            if (i >= 0 && i < this.c.length && j >= 0 && j < this.c[i].length) {
+                Chunk chunk = this.c[i][j];
+
+                if (chunk != null) {
+                    return chunk.getBlockData(blockposition);
+                }
+            }
+        }
+
+        return Blocks.AIR.getBlockData();
+    }
+
+    public boolean isEmpty(BlockPosition blockposition) {
+        return this.getType(blockposition).getMaterial() == Material.AIR;
+    }
+
+    public int getBlockPower(BlockPosition blockposition, EnumDirection enumdirection) {
+        return this.getType(blockposition).b(this, blockposition, enumdirection);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
new file mode 100644
index 00000000..f3a6799a
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -0,0 +1,61 @@
+package net.minecraft.server;
+
+import org.apache.commons.lang3.Validate;
+
+public class DataBits {
+
+    private final long[] a;
+    private final int b;
+    private final long c;
+    private final int d;
+
+    public DataBits(int i, int j) {
+        Validate.inclusiveBetween(1L, 32L, (long) i);
+        this.d = j;
+        this.b = i;
+        this.c = (1L << i) - 1L;
+        this.a = new long[MathHelper.c(j * i, 64) / 64];
+    }
+
+    public void a(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.c, (long) j);
+        int k = i * this.b;
+        int l = k / 64;
+        int i1 = ((i + 1) * this.b - 1) / 64;
+        int j1 = k % 64;
+
+        this.a[l] = this.a[l] & ~(this.c << j1) | ((long) j & this.c) << j1;
+        if (l != i1) {
+            int k1 = 64 - j1;
+            int l1 = this.b - k1;
+
+            this.a[i1] = this.a[i1] >>> l1 << l1 | ((long) j & this.c) >> k1;
+        }
+
+    }
+
+    public int a(int i) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        int j = i * this.b;
+        int k = j / 64;
+        int l = ((i + 1) * this.b - 1) / 64;
+        int i1 = j % 64;
+
+        if (k == l) {
+            return (int) (this.a[k] >>> i1 & this.c);
+        } else {
+            int j1 = 64 - i1;
+
+            return (int) ((this.a[k] >>> i1 | this.a[l] << j1) & this.c);
+        }
+    }
+
+    public long[] a() {
+        return this.a;
+    }
+
+    public int b() {
+        return this.d;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/NavigationAbstract.java b/src/main/java/net/minecraft/server/NavigationAbstract.java
new file mode 100644
index 00000000..bfc5769f
--- /dev/null
+++ b/src/main/java/net/minecraft/server/NavigationAbstract.java
@@ -0,0 +1,298 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public abstract class NavigationAbstract {
+
+    protected EntityInsentient a;
+    protected World b;
+    @Nullable
+    protected PathEntity c;
+    protected double d;
+    private final AttributeInstance i;
+    protected int e;
+    private int j;
+    private Vec3D k;
+    private Vec3D l;
+    private long m;
+    private long n;
+    private double o;
+    protected float f;
+    protected boolean g;
+    private long p;
+    protected PathfinderAbstract h;
+    private BlockPosition q;
+    private final Pathfinder r;
+
+    public NavigationAbstract(EntityInsentient entityinsentient, World world) {
+        this.k = Vec3D.a;
+        this.l = Vec3D.a;
+        this.f = 0.5F;
+        this.a = entityinsentient;
+        this.b = world;
+        this.i = entityinsentient.getAttributeInstance(GenericAttributes.FOLLOW_RANGE);
+        this.r = this.a();
+    }
+
+    protected abstract Pathfinder a();
+
+    public void a(double d0) {
+        this.d = d0;
+    }
+
+    public float i() {
+        return (float) this.i.getValue();
+    }
+
+    public boolean j() {
+        return this.g;
+    }
+
+    public void k() {
+        if (this.b.getTime() - this.p > 20L) {
+            if (this.q != null) {
+                this.c = null;
+                this.c = this.b(this.q);
+                this.p = this.b.getTime();
+                this.g = false;
+            }
+        } else {
+            this.g = true;
+        }
+
+    }
+
+    @Nullable
+    public final PathEntity a(double d0, double d1, double d2) {
+        return this.b(new BlockPosition(d0, d1, d2));
+    }
+
+    @Nullable
+    public PathEntity b(BlockPosition blockposition) {
+        if (!this.b()) {
+            return null;
+        } else if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+            return this.c;
+        } else {
+            this.q = blockposition;
+            float f = this.i();
+
+            this.b.methodProfiler.a("pathfind");
+            BlockPosition blockposition1 = new BlockPosition(this.a);
+            int i = (int) (f + 8.0F);
+            ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+            PathEntity pathentity = this.r.a(chunkcache, this.a, this.q, f);
+
+            this.b.methodProfiler.b();
+            return pathentity;
+        }
+    }
+
+    @Nullable
+    public PathEntity a(Entity entity) {
+        if (!this.b()) {
+            return null;
+        } else {
+            BlockPosition blockposition = new BlockPosition(entity);
+
+            if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+                return this.c;
+            } else {
+                this.q = blockposition;
+                float f = this.i();
+
+                this.b.methodProfiler.a("pathfind");
+                BlockPosition blockposition1 = (new BlockPosition(this.a)).up();
+                int i = (int) (f + 16.0F);
+                ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+                PathEntity pathentity = this.r.a(chunkcache, this.a, entity, f);
+
+                this.b.methodProfiler.b();
+                return pathentity;
+            }
+        }
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3) {
+        return this.a(this.a(d0, d1, d2), d3);
+    }
+
+    public boolean a(Entity entity, double d0) {
+        PathEntity pathentity = this.a(entity);
+
+        return pathentity != null && this.a(pathentity, d0);
+    }
+
+    public boolean a(@Nullable PathEntity pathentity, double d0) {
+        if (pathentity == null) {
+            this.c = null;
+            return false;
+        } else {
+            if (!pathentity.a(this.c)) {
+                this.c = pathentity;
+            }
+
+            this.q_();
+            if (this.c.d() <= 0) {
+                return false;
+            } else {
+                this.d = d0;
+                Vec3D vec3d = this.c();
+
+                this.j = this.e;
+                this.k = vec3d;
+                return true;
+            }
+        }
+    }
+
+    @Nullable
+    public PathEntity l() {
+        return this.c;
+    }
+
+    public void d() {
+        ++this.e;
+        if (this.g) {
+            this.k();
+        }
+
+        if (!this.o()) {
+            Vec3D vec3d;
+
+            if (this.b()) {
+                this.n();
+            } else if (this.c != null && this.c.e() < this.c.d()) {
+                vec3d = this.c();
+                Vec3D vec3d1 = this.c.a(this.a, this.c.e());
+
+                if (vec3d.y > vec3d1.y && !this.a.onGround && MathHelper.floor(vec3d.x) == MathHelper.floor(vec3d1.x) && MathHelper.floor(vec3d.z) == MathHelper.floor(vec3d1.z)) {
+                    this.c.c(this.c.e() + 1);
+                }
+            }
+
+            this.m();
+            if (!this.o()) {
+                vec3d = this.c.a((Entity) this.a);
+                BlockPosition blockposition = (new BlockPosition(vec3d)).down();
+                AxisAlignedBB axisalignedbb = this.b.getType(blockposition).e(this.b, blockposition);
+
+                vec3d = vec3d.a(0.0D, 1.0D - axisalignedbb.e, 0.0D);
+                this.a.getControllerMove().a(vec3d.x, vec3d.y, vec3d.z, this.d);
+            }
+        }
+    }
+
+    protected void m() {}
+
+    protected void n() {
+        Vec3D vec3d = this.c();
+        int i = this.c.d();
+
+        for (int j = this.c.e(); j < this.c.d(); ++j) {
+            if ((double) this.c.a(j).b != Math.floor(vec3d.y)) {
+                i = j;
+                break;
+            }
+        }
+
+        this.f = this.a.width > 0.75F ? this.a.width / 2.0F : 0.75F - this.a.width / 2.0F;
+        Vec3D vec3d1 = this.c.f();
+
+        if (MathHelper.e((float) (this.a.locX - (vec3d1.x + 0.5D))) < this.f && MathHelper.e((float) (this.a.locZ - (vec3d1.z + 0.5D))) < this.f && Math.abs(this.a.locY - vec3d1.y) < 1.0D) {
+            this.c.c(this.c.e() + 1);
+        }
+
+        int k = MathHelper.f(this.a.width);
+        int l = MathHelper.f(this.a.length);
+        int i1 = k;
+
+        for (int j1 = i - 1; j1 >= this.c.e(); --j1) {
+            if (this.a(vec3d, this.c.a(this.a, j1), k, l, i1)) {
+                this.c.c(j1);
+                break;
+            }
+        }
+
+        this.a(vec3d);
+    }
+
+    protected void a(Vec3D vec3d) {
+        if (this.e - this.j > 100) {
+            if (vec3d.distanceSquared(this.k) < 2.25D) {
+                this.p();
+            }
+
+            this.j = this.e;
+            this.k = vec3d;
+        }
+
+        if (this.c != null && !this.c.b()) {
+            Vec3D vec3d1 = this.c.f();
+
+            if (vec3d1.equals(this.l)) {
+                this.m += System.currentTimeMillis() - this.n;
+            } else {
+                this.l = vec3d1;
+                double d0 = vec3d.f(this.l);
+
+                this.o = this.a.cy() > 0.0F ? d0 / (double) this.a.cy() * 1000.0D : 0.0D;
+            }
+
+            if (this.o > 0.0D && (double) this.m > this.o * 3.0D) {
+                this.l = Vec3D.a;
+                this.m = 0L;
+                this.o = 0.0D;
+                this.p();
+            }
+
+            this.n = System.currentTimeMillis();
+        }
+
+    }
+
+    public boolean o() {
+        return this.c == null || this.c.b();
+    }
+
+    public void p() {
+        this.c = null;
+    }
+
+    protected abstract Vec3D c();
+
+    protected abstract boolean b();
+
+    protected boolean q() {
+        return this.a.isInWater() || this.a.au();
+    }
+
+    protected void q_() {
+        if (this.c != null) {
+            for (int i = 0; i < this.c.d(); ++i) {
+                PathPoint pathpoint = this.c.a(i);
+                PathPoint pathpoint1 = i + 1 < this.c.d() ? this.c.a(i + 1) : null;
+                IBlockData iblockdata = this.b.getType(new BlockPosition(pathpoint.a, pathpoint.b, pathpoint.c));
+                Block block = iblockdata.getBlock();
+
+                if (block == Blocks.cauldron) {
+                    this.c.a(i, pathpoint.a(pathpoint.a, pathpoint.b + 1, pathpoint.c));
+                    if (pathpoint1 != null && pathpoint.b >= pathpoint1.b) {
+                        this.c.a(i + 1, pathpoint1.a(pathpoint1.a, pathpoint.b + 1, pathpoint1.c));
+                    }
+                }
+            }
+
+        }
+    }
+
+    protected abstract boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k);
+
+    public boolean a(BlockPosition blockposition) {
+        return this.b.getType(blockposition.down()).b();
+    }
+
+    public PathfinderAbstract r() {
+        return this.h;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/PersistentVillage.java b/src/main/java/net/minecraft/server/PersistentVillage.java
new file mode 100644
index 00000000..a5b79eca
--- /dev/null
+++ b/src/main/java/net/minecraft/server/PersistentVillage.java
@@ -0,0 +1,269 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+
+public class PersistentVillage extends PersistentBase {
+
+    private World world;
+    private final List<BlockPosition> c = Lists.newArrayList();
+    private final List<VillageDoor> d = Lists.newArrayList();
+    private final List<Village> villages = Lists.newArrayList();
+    private int time;
+
+    public PersistentVillage(String s) {
+        super(s);
+    }
+
+    public PersistentVillage(World world) {
+        super(a(world.worldProvider));
+        this.world = world;
+        this.c();
+    }
+
+    public void a(World world) {
+        this.world = world;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(world);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition) {
+        if (this.c.size() <= 64) {
+            if (!this.e(blockposition)) {
+                this.c.add(blockposition);
+            }
+
+        }
+    }
+
+    public void tick() {
+        ++this.time;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(this.time);
+        }
+
+        this.e();
+        this.f();
+        this.g();
+        if (this.time % 400 == 0) {
+            this.c();
+        }
+
+    }
+
+    private void e() {
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            if (village.g()) {
+                iterator.remove();
+                this.c();
+            }
+        }
+
+    }
+
+    public List<Village> getVillages() {
+        return this.villages;
+    }
+
+    public Village getClosestVillage(BlockPosition blockposition, int i) {
+        Village village = null;
+        double d0 = 3.4028234663852886E38D;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village1 = (Village) iterator.next();
+            double d1 = village1.a().n(blockposition);
+
+            if (d1 < d0) {
+                float f = (float) (i + village1.b());
+
+                if (d1 <= (double) (f * f)) {
+                    village = village1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return village;
+    }
+
+    private void f() {
+        if (!this.c.isEmpty()) {
+            this.b((BlockPosition) this.c.remove(0));
+        }
+    }
+
+    private void g() {
+        for (int i = 0; i < this.d.size(); ++i) {
+            VillageDoor villagedoor = (VillageDoor) this.d.get(i);
+            Village village = this.getClosestVillage(villagedoor.d(), 32);
+
+            if (village == null) {
+                village = new Village(this.world);
+                this.villages.add(village);
+                this.c();
+            }
+
+            village.a(villagedoor);
+        }
+
+        this.d.clear();
+    }
+
+    private void b(BlockPosition blockposition) {
+        boolean flag = true;
+        boolean flag1 = true;
+        boolean flag2 = true;
+
+        for (int i = -16; i < 16; ++i) {
+            for (int j = -4; j < 4; ++j) {
+                for (int k = -16; k < 16; ++k) {
+                    BlockPosition blockposition1 = blockposition.a(i, j, k);
+
+                    if (this.f(blockposition1)) {
+                        VillageDoor villagedoor = this.c(blockposition1);
+
+                        if (villagedoor == null) {
+                            this.d(blockposition1);
+                        } else {
+                            villagedoor.a(this.time);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    @Nullable
+    private VillageDoor c(BlockPosition blockposition) {
+        Iterator iterator = this.d.iterator();
+
+        VillageDoor villagedoor;
+
+        do {
+            if (!iterator.hasNext()) {
+                iterator = this.villages.iterator();
+
+                VillageDoor villagedoor1;
+
+                do {
+                    if (!iterator.hasNext()) {
+                        return null;
+                    }
+
+                    Village village = (Village) iterator.next();
+
+                    villagedoor1 = village.e(blockposition);
+                } while (villagedoor1 == null);
+
+                return villagedoor1;
+            }
+
+            villagedoor = (VillageDoor) iterator.next();
+        } while (villagedoor.d().getX() != blockposition.getX() || villagedoor.d().getZ() != blockposition.getZ() || Math.abs(villagedoor.d().getY() - blockposition.getY()) > 1);
+
+        return villagedoor;
+    }
+
+    private void d(BlockPosition blockposition) {
+        EnumDirection enumdirection = BlockDoor.f(this.world, blockposition);
+        EnumDirection enumdirection1 = enumdirection.opposite();
+        int i = this.a(blockposition, enumdirection, 5);
+        int j = this.a(blockposition, enumdirection1, i + 1);
+
+        if (i != j) {
+            this.d.add(new VillageDoor(blockposition, i < j ? enumdirection : enumdirection1, this.time));
+        }
+
+    }
+
+    private int a(BlockPosition blockposition, EnumDirection enumdirection, int i) {
+        int j = 0;
+
+        for (int k = 1; k <= 5; ++k) {
+            if (this.world.h(blockposition.shift(enumdirection, k))) {
+                ++j;
+                if (j >= i) {
+                    return j;
+                }
+            }
+        }
+
+        return j;
+    }
+
+    private boolean e(BlockPosition blockposition) {
+        Iterator iterator = this.c.iterator();
+
+        BlockPosition blockposition1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            blockposition1 = (BlockPosition) iterator.next();
+        } while (!blockposition1.equals(blockposition));
+
+        return true;
+    }
+
+    private boolean f(BlockPosition blockposition) {
+        IBlockData iblockdata = this.world.getType(blockposition);
+        Block block = iblockdata.getBlock();
+
+        return block instanceof BlockDoor ? iblockdata.getMaterial() == Material.WOOD : false;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        this.time = nbttagcompound.getInt("Tick");
+        NBTTagList nbttaglist = nbttagcompound.getList("Villages", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.get(i);
+            Village village = new Village();
+
+            village.a(nbttagcompound1);
+            this.villages.add(village);
+        }
+
+    }
+
+    public NBTTagCompound b(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("Tick", this.time);
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            village.b(nbttagcompound1);
+            nbttaglist.add(nbttagcompound1);
+        }
+
+        nbttagcompound.set("Villages", nbttaglist);
+        return nbttagcompound;
+    }
+
+    public static String a(WorldProvider worldprovider) {
+        return "villages" + worldprovider.getDimensionManager().c();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityEnderChest.java b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
new file mode 100644
index 00000000..31585757
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
@@ -0,0 +1,87 @@
+package net.minecraft.server;
+
+public class TileEntityEnderChest extends TileEntity implements ITickable {
+
+    public float a;
+    public float f;
+    public int g;
+    private int h;
+
+    public TileEntityEnderChest() {}
+
+    public void e() {
+        if (++this.h % 20 * 4 == 0) {
+            this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.g);
+        }
+
+        this.f = this.a;
+        int i = this.position.getX();
+        int j = this.position.getY();
+        int k = this.position.getZ();
+        float f = 0.1F;
+        double d0;
+
+        if (this.g > 0 && this.a == 0.0F) {
+            double d1 = (double) i + 0.5D;
+
+            d0 = (double) k + 0.5D;
+            this.world.a((EntityHuman) null, d1, (double) j + 0.5D, d0, SoundEffects.aT, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+        }
+
+        if (this.g == 0 && this.a > 0.0F || this.g > 0 && this.a < 1.0F) {
+            float f1 = this.a;
+
+            if (this.g > 0) {
+                this.a += 0.1F;
+            } else {
+                this.a -= 0.1F;
+            }
+
+            if (this.a > 1.0F) {
+                this.a = 1.0F;
+            }
+
+            float f2 = 0.5F;
+
+            if (this.a < 0.5F && f1 >= 0.5F) {
+                d0 = (double) i + 0.5D;
+                double d2 = (double) k + 0.5D;
+
+                this.world.a((EntityHuman) null, d0, (double) j + 0.5D, d2, SoundEffects.aS, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+            }
+
+            if (this.a < 0.0F) {
+                this.a = 0.0F;
+            }
+        }
+
+    }
+
+    public boolean c(int i, int j) {
+        if (i == 1) {
+            this.g = j;
+            return true;
+        } else {
+            return super.c(i, j);
+        }
+    }
+
+    public void z() {
+        this.invalidateBlockCache();
+        super.z();
+    }
+
+    public void a() {
+        ++this.g;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.g);
+    }
+
+    public void f() {
+        --this.g;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.g);
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return this.world.getTileEntity(this.position) != this ? false : entityhuman.d((double) this.position.getX() + 0.5D, (double) this.position.getY() + 0.5D, (double) this.position.getZ() + 0.5D) <= 64.0D;
+    }
+}
-- 
2.15.2 (Apple Git-101.1)

