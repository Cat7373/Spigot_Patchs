From be745c591d39fb41b6fcc59cfd274a9783a42e45 Mon Sep 17 00:00:00 2001
From: Cat73 <root@cat73.org>
Date: Tue, 25 Feb 2020 23:13:57 +0800
Subject: [PATCH] Cat73 -> Optimize Hoppers
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

优化漏斗占用的 CPU

Link: https://github.com/PaperMC/Paper/blob/892f479fb4ef849ba834cbedd0069395cc1bef14/Spigot-Server-Patches/0417-Optimize-Hoppers.patch

diff --git a/src/main/java/net/minecraft/server/ItemStack.java b/src/main/java/net/minecraft/server/ItemStack.java
index 75308712..d22a2b1a 100644
--- a/src/main/java/net/minecraft/server/ItemStack.java
+++ b/src/main/java/net/minecraft/server/ItemStack.java
@@ -452,11 +452,12 @@ public final class ItemStack {
         return this.getItem().a(this, entityhuman, entityliving, enumhand);
     }
 
-    public ItemStack cloneItemStack() {
-        if (this.isEmpty()) {
+    public ItemStack cloneItemStack() { return cloneItemStack(false); } // Paper
+    public ItemStack cloneItemStack(boolean origItem) { // Paper
+        if (!origItem && this.isEmpty()) { // Paper
             return ItemStack.a;
         } else {
-            ItemStack itemstack = new ItemStack(this.getItem(), this.count);
+            ItemStack itemstack = new ItemStack(origItem ? this.item : this.getItem(), this.count); // Paper
 
             itemstack.d(this.C());
             if (this.tag != null) {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 41e2ba49..c64fde62 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1064,6 +1064,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
         while (iterator.hasNext()) {
             WorldServer worldserver = (WorldServer) iterator.next();
 
+            TileEntityHopper.skipHopperEvents = org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper
             if (true || worldserver.worldProvider.getDimensionManager() == DimensionManager.OVERWORLD || this.getAllowNether()) { // CraftBukkit
                 this.methodProfiler.a(() -> {
                     return worldserver.getWorldData().getName() + " " + IRegistry.DIMENSION_TYPE.getKey(worldserver.worldProvider.getDimensionManager());
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index 0113ba02..074a6c40 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -27,6 +27,7 @@ public abstract class TileEntity {
     @Nullable
     private IBlockData c;
     private boolean g;
+    static boolean IGNORE_TILE_UPDATES = false;
 
     public TileEntity(TileEntityTypes<?> tileentitytypes) {
         this.position = BlockPosition.ZERO;
@@ -109,6 +110,7 @@ public abstract class TileEntity {
 
     public void update() {
         if (this.world != null) {
+            if (IGNORE_TILE_UPDATES) return; // Paper
             this.c = this.world.getType(this.position);
             this.world.b(this.position, this);
             if (!this.c.isAir()) {
diff --git a/src/main/java/net/minecraft/server/TileEntityHopper.java b/src/main/java/net/minecraft/server/TileEntityHopper.java
index 907d088c..4db6491b 100644
--- a/src/main/java/net/minecraft/server/TileEntityHopper.java
+++ b/src/main/java/net/minecraft/server/TileEntityHopper.java
@@ -168,6 +168,158 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
         return false;
     }
 
+    // Paper start - Optimize Hoppers
+    private static boolean skipPullModeEventFire = false;
+    private static boolean skipPushModeEventFire = false;
+    static boolean skipHopperEvents = false;
+
+    private boolean hopperPush(IInventory iinventory, EnumDirection enumdirection) {
+        skipPushModeEventFire = skipHopperEvents;
+        boolean foundItem = false;
+        for (int i = 0; i < this.getSize(); ++i) {
+            if (!this.getItem(i).isEmpty()) {
+                foundItem = true;
+                ItemStack origItemStack = this.getItem(i);
+                ItemStack itemstack = origItemStack;
+
+                final int origCount = origItemStack.getCount();
+                final int moved = Math.min(world.spigotConfig.hopperAmount, origCount);
+                origItemStack.setCount(moved);
+
+                // We only need to fire the event once to give protection plugins a chance to cancel this event
+                // Because nothing uses getItem, every event call should end up the same result.
+                if (!skipPushModeEventFire) {
+                    itemstack = callPushMoveEvent(iinventory, itemstack);
+                    if (itemstack == null) { // cancelled
+                        origItemStack.setCount(origCount);
+                        return false;
+                    }
+                }
+                final ItemStack itemstack2 = addItem(this, iinventory, itemstack, enumdirection);
+                final int remaining = itemstack2.getCount();
+                if (remaining != moved) {
+                    origItemStack = origItemStack.cloneItemStack(true);
+                    origItemStack.setCount(origCount);
+                    if (!origItemStack.isEmpty()) {
+                        origItemStack.setCount(origCount - moved + remaining);
+                    }
+                    this.setItem(i, origItemStack);
+                    iinventory.update();
+                    return true;
+                }
+                origItemStack.setCount(origCount);
+            }
+        }
+        if (foundItem) { // Inventory was full - cooldown
+            this.setCooldown(world.spigotConfig.hopperTransfer);
+        }
+        return false;
+    }
+
+    private static boolean hopperPull(IHopper ihopper, IInventory iinventory, int i) {
+        ItemStack origItemStack = iinventory.getItem(i);
+        ItemStack itemstack = origItemStack;
+        final int origCount = origItemStack.getCount();
+        final World world = ihopper.getWorld();
+        final int moved = Math.min(world.spigotConfig.hopperAmount, origCount);
+        itemstack.setCount(moved);
+
+        if (!skipPullModeEventFire) {
+            itemstack = callPullMoveEvent(ihopper, iinventory, itemstack);
+            if (itemstack == null) { // cancelled
+                origItemStack.setCount(origCount);
+                // Drastically improve performance by returning true.
+                // No plugin could of relied on the behavior of false as the other call
+                // site for IMIE did not exhibit the same behavior
+                return true;
+            }
+        }
+
+        final ItemStack itemstack2 = addItem(iinventory, ihopper, itemstack, null);
+        final int remaining = itemstack2.getCount();
+        if (remaining != moved) {
+            origItemStack = origItemStack.cloneItemStack(true);
+            origItemStack.setCount(origCount);
+            if (!origItemStack.isEmpty()) {
+                origItemStack.setCount(origCount - moved + remaining);
+            }
+            IGNORE_TILE_UPDATES = true;
+            iinventory.setItem(i, origItemStack);
+            IGNORE_TILE_UPDATES = false;
+            iinventory.update();
+            return true;
+        }
+        origItemStack.setCount(origCount);
+
+        cooldownHopper(ihopper);
+
+        return false;
+    }
+
+    private ItemStack callPushMoveEvent(IInventory iinventory, ItemStack itemstack) {
+        Inventory destinationInventory = getInventory(iinventory);
+        InventoryMoveItemEvent event = new InventoryMoveItemEvent(this.getOwner(false).getInventory(),
+            CraftItemStack.asCraftMirror(itemstack), destinationInventory, true);
+        boolean result = event.callEvent();
+        if (!event.calledGetItem && !event.calledSetItem) {
+            skipPushModeEventFire = true;
+        }
+        if (!result) {
+            cooldownHopper(this);
+            return null;
+        }
+
+        if (event.calledSetItem) {
+            return CraftItemStack.asNMSCopy(event.getItem());
+        } else {
+            return itemstack;
+        }
+    }
+
+    private static ItemStack callPullMoveEvent(IHopper hopper, IInventory iinventory, ItemStack itemstack) {
+        Inventory sourceInventory = getInventory(iinventory);
+        Inventory destination = getInventory(hopper);
+
+        InventoryMoveItemEvent event = new InventoryMoveItemEvent(sourceInventory,
+            // Mirror is safe as we no plugins ever use this item
+            CraftItemStack.asCraftMirror(itemstack), destination, false);
+        boolean result = event.callEvent();
+        if (!event.calledGetItem && !event.calledSetItem) {
+            skipPullModeEventFire = true;
+        }
+        if (!result) {
+            cooldownHopper(hopper);
+            return null;
+        }
+
+        if (event.calledSetItem) {
+            return CraftItemStack.asNMSCopy(event.getItem());
+        } else {
+            return itemstack;
+        }
+    }
+
+    private static Inventory getInventory(IInventory iinventory) {
+        Inventory sourceInventory;// Have to special case large chests as they work oddly
+        if (iinventory instanceof InventoryLargeChest) {
+            sourceInventory = new org.bukkit.craftbukkit.inventory.CraftInventoryDoubleChest((InventoryLargeChest) iinventory);
+        } else if (iinventory instanceof TileEntity) {
+            sourceInventory = ((TileEntity) iinventory).getOwner(false).getInventory();
+        } else {
+            sourceInventory = iinventory.getOwner().getInventory();
+        }
+        return sourceInventory;
+    }
+
+    private static void cooldownHopper(IHopper hopper) {
+        if (hopper instanceof TileEntityHopper) {
+            ((TileEntityHopper) hopper).setCooldown(hopper.getWorld().spigotConfig.hopperTransfer);
+        } else if (hopper instanceof EntityMinecartHopper) {
+            ((EntityMinecartHopper) hopper).setCooldown(hopper.getWorld().spigotConfig.hopperTransfer / 2);
+        }
+    }
+    // Paper end
+
     private boolean j() {
         IInventory iinventory = this.k();
 
@@ -179,6 +331,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
             if (this.b(iinventory, enumdirection)) {
                 return false;
             } else {
+                return hopperPush(iinventory, enumdirection); /* // Paper - disable rest
                 for (int i = 0; i < this.getSize(); ++i) {
                     if (!this.getItem(i).isEmpty()) {
                         ItemStack itemstack = this.getItem(i).cloneItemStack();
@@ -216,7 +369,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
                     }
                 }
 
-                return false;
+                return false;*/ // Paper - end commenting out replaced block for Hopper Optimizations
             }
         }
     }
@@ -246,6 +399,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
             EnumDirection enumdirection = EnumDirection.DOWN;
 
             return c(iinventory, enumdirection) ? false : a(iinventory, enumdirection).anyMatch((i) -> {
+                skipPullModeEventFire = skipHopperEvents; // Paper
                 return a(ihopper, iinventory, i, enumdirection);
             });
         } else {
@@ -269,6 +423,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
         ItemStack itemstack = iinventory.getItem(i);
 
         if (!itemstack.isEmpty() && b(iinventory, itemstack, i, enumdirection)) {
+            return hopperPull(ihopper, iinventory, i); /* // Paper - disable rest
             ItemStack itemstack1 = itemstack.cloneItemStack();
             // ItemStack itemstack2 = addItem(iinventory, ihopper, iinventory.splitStack(i, 1), (EnumDirection) null);
             // CraftBukkit start - Call event on collection of items from inventories into the hopper
@@ -305,7 +460,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
             }
 
             itemstack1.subtract(origCount - itemstack2.getCount()); // Spigot
-            iinventory.setItem(i, itemstack1);
+            iinventory.setItem(i, itemstack1);*/ // Paper - end commenting out replaced block for Hopper Optimizations
         }
 
         return false;
@@ -314,7 +469,7 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
     public static boolean a(IInventory iinventory, EntityItem entityitem) {
         boolean flag = false;
         // CraftBukkit start
-        InventoryPickupItemEvent event = new InventoryPickupItemEvent(iinventory.getOwner().getInventory(), (org.bukkit.entity.Item) entityitem.getBukkitEntity());
+        InventoryPickupItemEvent event = new InventoryPickupItemEvent(getInventory(iinventory), (org.bukkit.entity.Item) entityitem.getBukkitEntity()); // Paper - use getInventory() to avoid snapshot creation
         entityitem.world.getServer().getPluginManager().callEvent(event);
         if (event.isCancelled()) {
             return false;
@@ -368,7 +523,9 @@ public class TileEntityHopper extends TileEntityLootable implements IHopper, ITi
             boolean flag1 = iinventory1.isEmpty();
 
             if (itemstack1.isEmpty()) {
+                IGNORE_TILE_UPDATES = true; // Paper
                 iinventory1.setItem(i, itemstack);
+                IGNORE_TILE_UPDATES = false; // Paper
                 itemstack = ItemStack.a;
                 flag = true;
             } else if (a(itemstack1, itemstack)) {
-- 
2.25.0

