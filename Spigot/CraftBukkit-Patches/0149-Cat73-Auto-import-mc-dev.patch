From a6378fe418c837b89d54ce20f33ba89b1a3b6123 Mon Sep 17 00:00:00 2001
From: Cat73 <1901803382@qq.com>
Date: Mon, 13 Jun 2016 20:02:15 +0800
Subject: [PATCH] Cat73 -> Auto import mc-dev


diff --git a/src/main/java/net/minecraft/server/ChunkCache.java b/src/main/java/net/minecraft/server/ChunkCache.java
new file mode 100644
index 0000000..a8fd64c
--- /dev/null
+++ b/src/main/java/net/minecraft/server/ChunkCache.java
@@ -0,0 +1,76 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public class ChunkCache implements IBlockAccess {
+
+    protected int a;
+    protected int b;
+    protected Chunk[][] c;
+    protected boolean d;
+    protected World e;
+
+    public ChunkCache(World world, BlockPosition blockposition, BlockPosition blockposition1, int i) {
+        this.e = world;
+        this.a = blockposition.getX() - i >> 4;
+        this.b = blockposition.getZ() - i >> 4;
+        int j = blockposition1.getX() + i >> 4;
+        int k = blockposition1.getZ() + i >> 4;
+
+        this.c = new Chunk[j - this.a + 1][k - this.b + 1];
+        this.d = true;
+
+        int l;
+        int i1;
+
+        for (l = this.a; l <= j; ++l) {
+            for (i1 = this.b; i1 <= k; ++i1) {
+                this.c[l - this.a][i1 - this.b] = world.getChunkAt(l, i1);
+            }
+        }
+
+        for (l = blockposition.getX() >> 4; l <= blockposition1.getX() >> 4; ++l) {
+            for (i1 = blockposition.getZ() >> 4; i1 <= blockposition1.getZ() >> 4; ++i1) {
+                Chunk chunk = this.c[l - this.a][i1 - this.b];
+
+                if (chunk != null && !chunk.c(blockposition.getY(), blockposition1.getY())) {
+                    this.d = false;
+                }
+            }
+        }
+
+    }
+
+    @Nullable
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        int i = (blockposition.getX() >> 4) - this.a;
+        int j = (blockposition.getZ() >> 4) - this.b;
+
+        return this.c[i][j].a(blockposition, Chunk.EnumTileEntityState.IMMEDIATE);
+    }
+
+    public IBlockData getType(BlockPosition blockposition) {
+        if (blockposition.getY() >= 0 && blockposition.getY() < 256) {
+            int i = (blockposition.getX() >> 4) - this.a;
+            int j = (blockposition.getZ() >> 4) - this.b;
+
+            if (i >= 0 && i < this.c.length && j >= 0 && j < this.c[i].length) {
+                Chunk chunk = this.c[i][j];
+
+                if (chunk != null) {
+                    return chunk.getBlockData(blockposition);
+                }
+            }
+        }
+
+        return Blocks.AIR.getBlockData();
+    }
+
+    public boolean isEmpty(BlockPosition blockposition) {
+        return this.getType(blockposition).getMaterial() == Material.AIR;
+    }
+
+    public int getBlockPower(BlockPosition blockposition, EnumDirection enumdirection) {
+        return this.getType(blockposition).b(this, blockposition, enumdirection);
+    }
+}
diff --git a/src/main/java/net/minecraft/server/DataBits.java b/src/main/java/net/minecraft/server/DataBits.java
new file mode 100644
index 0000000..f3a6799
--- /dev/null
+++ b/src/main/java/net/minecraft/server/DataBits.java
@@ -0,0 +1,61 @@
+package net.minecraft.server;
+
+import org.apache.commons.lang3.Validate;
+
+public class DataBits {
+
+    private final long[] a;
+    private final int b;
+    private final long c;
+    private final int d;
+
+    public DataBits(int i, int j) {
+        Validate.inclusiveBetween(1L, 32L, (long) i);
+        this.d = j;
+        this.b = i;
+        this.c = (1L << i) - 1L;
+        this.a = new long[MathHelper.c(j * i, 64) / 64];
+    }
+
+    public void a(int i, int j) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        Validate.inclusiveBetween(0L, this.c, (long) j);
+        int k = i * this.b;
+        int l = k / 64;
+        int i1 = ((i + 1) * this.b - 1) / 64;
+        int j1 = k % 64;
+
+        this.a[l] = this.a[l] & ~(this.c << j1) | ((long) j & this.c) << j1;
+        if (l != i1) {
+            int k1 = 64 - j1;
+            int l1 = this.b - k1;
+
+            this.a[i1] = this.a[i1] >>> l1 << l1 | ((long) j & this.c) >> k1;
+        }
+
+    }
+
+    public int a(int i) {
+        Validate.inclusiveBetween(0L, (long) (this.d - 1), (long) i);
+        int j = i * this.b;
+        int k = j / 64;
+        int l = ((i + 1) * this.b - 1) / 64;
+        int i1 = j % 64;
+
+        if (k == l) {
+            return (int) (this.a[k] >>> i1 & this.c);
+        } else {
+            int j1 = 64 - i1;
+
+            return (int) ((this.a[k] >>> i1 | this.a[l] << j1) & this.c);
+        }
+    }
+
+    public long[] a() {
+        return this.a;
+    }
+
+    public int b() {
+        return this.d;
+    }
+}
diff --git a/src/main/java/net/minecraft/server/TileEntityEnderChest.java b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
new file mode 100644
index 0000000..d5f0d61
--- /dev/null
+++ b/src/main/java/net/minecraft/server/TileEntityEnderChest.java
@@ -0,0 +1,87 @@
+package net.minecraft.server;
+
+public class TileEntityEnderChest extends TileEntity implements ITickable {
+
+    public float a;
+    public float f;
+    public int g;
+    private int h;
+
+    public TileEntityEnderChest() {}
+
+    public void E_() {
+        if (++this.h % 20 * 4 == 0) {
+            this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.g);
+        }
+
+        this.f = this.a;
+        int i = this.position.getX();
+        int j = this.position.getY();
+        int k = this.position.getZ();
+        float f = 0.1F;
+        double d0;
+
+        if (this.g > 0 && this.a == 0.0F) {
+            double d1 = (double) i + 0.5D;
+
+            d0 = (double) k + 0.5D;
+            this.world.a((EntityHuman) null, d1, (double) j + 0.5D, d0, SoundEffects.aN, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+        }
+
+        if (this.g == 0 && this.a > 0.0F || this.g > 0 && this.a < 1.0F) {
+            float f1 = this.a;
+
+            if (this.g > 0) {
+                this.a += 0.1F;
+            } else {
+                this.a -= 0.1F;
+            }
+
+            if (this.a > 1.0F) {
+                this.a = 1.0F;
+            }
+
+            float f2 = 0.5F;
+
+            if (this.a < 0.5F && f1 >= 0.5F) {
+                d0 = (double) i + 0.5D;
+                double d2 = (double) k + 0.5D;
+
+                this.world.a((EntityHuman) null, d0, (double) j + 0.5D, d2, SoundEffects.aM, SoundCategory.BLOCKS, 0.5F, this.world.random.nextFloat() * 0.1F + 0.9F);
+            }
+
+            if (this.a < 0.0F) {
+                this.a = 0.0F;
+            }
+        }
+
+    }
+
+    public boolean c(int i, int j) {
+        if (i == 1) {
+            this.g = j;
+            return true;
+        } else {
+            return super.c(i, j);
+        }
+    }
+
+    public void y() {
+        this.invalidateBlockCache();
+        super.y();
+    }
+
+    public void d() {
+        ++this.g;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.g);
+    }
+
+    public void e() {
+        --this.g;
+        this.world.playBlockAction(this.position, Blocks.ENDER_CHEST, 1, this.g);
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return this.world.getTileEntity(this.position) != this ? false : entityhuman.e((double) this.position.getX() + 0.5D, (double) this.position.getY() + 0.5D, (double) this.position.getZ() + 0.5D) <= 64.0D;
+    }
+}
-- 
2.8.3.windows.1

